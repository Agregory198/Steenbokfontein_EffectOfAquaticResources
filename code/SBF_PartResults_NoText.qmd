---
title: "Steenbokfontein Preliminary Results"
execute: 
  echo: false
  warning: false
  message: false
format: html
editor: visual
---

```{r library}
#| warning: false
#| message: false


# To plot figures
library(ggplot2)
library(forcats)
library(ggpubr)
library(ggridges)
library(cowplot)

library(infer)
#library(rcompanion)
library(purrr)
#library(rcompanion)
library(viridis)

library(scales)
library(stringr)

# To generate tables
library(gtsummary)
library(gt)
library(broom)
library(broom.mixed)

library(stargazer)
library(kableExtra)

# To tidy the data
library(tidyr)
library(tidyverse)
library(dplyr)
library(forcats)
library(tidybayes)

# Bayesian models
library(brms)
library(emmeans)
library(loo)
library(BayesFactor)
library(posterior)
```

```{r ScraperRetouchFormula}
# Calculate scraper retouch intensity
scraper_red <- function(L, D, a, b){
  
  t = D * sin(a)
  D3 = D * cos(a)
  D1 = t/(sin(b))
  D4 = (t * cos(b))/(sin(b))
  
  D2 = D4 - D3
  
  B = t * (sin(b)) # define base B to find height (which is also D1)
  
  h = sin(b) * ((t*(cos(b)/sin(b))) - (D*cos(a)))
  
  A =  0.5 * B * h# find values of area now
  
  RE = L*((D^2)/2)*((sin(a*(pi/180))^2 * 
                       (cos(b*(pi/180))/sin(b*(pi/180)))) - 
                      (sin(a*(pi/180)) * cos(a*(pi/180))))
  
  
  output <- tibble(Reduction = RE)
  
  return(output)
  
  
}
```

```{r ReadData}
#| message: false
#| warning: false

# Read and clean data
df_sum24 <- read.csv("../data/AG_Summer2024_SBF_Final.csv") |>
  select(-c('X')) |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"), "Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))

df_sum25 <- read.csv("../data/AG_Summer2025_SBF_Final.csv") |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  select(-c(X))

# student's dataframe
df_One <- read_csv("../data/DataSheet_1.csv")|>
  mutate(STRAT = tolower(Layer),
         
         PLATFORMWIDTH = parse_number("Platform Width"),
         PLATFORMTHICKNESS = parse_number("Platform Thickness"),
         MAXLENGTH = parse_number("Maximum Length"),
         TECHLENGTH = parse_number("Technological Length"),
         MAXWIDTH = parse_number("Maximum Width"),
         TECHWIDTH = parse_number("Technological Width"),
         MAXTHICKNESS = parse_number("Thickness"),
         MASS = parse_number("Mass"))

df_One <- df_One[1:289,]

df_One_flakes <- df_One |>
  
  add_column(OTHERUNIT = NA, .before = "Raw Material") |>

  rename(SITE = Site, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         CORTEXTYPE = `Cortex Origin`, ARTIFACTCLASS = `Artifact class`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = PlatformAbrasion, 
         STAGE = `Flaking Stage`) |>
  
  select(-c(Layer, Notes, Photo,
            `Platform Width`:`Platform Thickness`, `Maximum Length`:Mass)) |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                      ifelse(STRAT == "3b", "3", 
                             ifelse(STRAT == "5a", "5", STRAT))),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  relocate(STRAT, .before = "UNIT") |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  
  

# student's Dataframe
df_Two <- read_csv("../data/DataSheet_2.csv") |>
  
  rename(SITE = Site, STRAT = Layer, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         ARTIFACTCLASS = `Artifact class`, CORTEXTYPE = `Cortex Origin`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = `PlatformAbrasion`, PLATFORMWIDTH = `Platform Width`,
         PLATFORMTHICKNESS = `Platform Thickness`, STAGE = `Flaking Stage`,
         MAXLENGTH = `Maximum Length`, TECHLENGTH = `Technological Length`,
         MAXWIDTH = `Maximum Width`, TECHWIDTH = `Technological Width`,
         MAXTHICKNESS = Thickness, MASS = Mass) |>
  
  select(-c(`...2`,Notes:Photo))

df_Two_flakes <- df_Two |>
  
  add_column(OTHERUNIT = NA, .before = "RAWMATERIAL") |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                    ifelse(STRAT == "3b", "3", 
                           ifelse(STRAT == "5a", "5", STRAT))),
          STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))




df_Two_flakes <- df_Two_flakes[1:421,] |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  

df_students <- rbind(df_Two_flakes, df_One_flakes)


df <- rbind(df_sum24, df_sum25) |>
  merge(df_students, all = T) |>
  mutate(TECHLENGTH = as.numeric(TECHLENGTH),
         MAXWIDTH = as.numeric(MAXWIDTH),
         MAXTHICKNESS = as.numeric(MAXTHICKNESS)) |>
  filter(STRAT %in% c("1", "2", "3", "4a", "4b", "5")) |>
  
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS == "flake", "Flake",
                         ifelse(ARTIFACTCLASS == "blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Flake/Blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Fragment", "Flake",
                                                     ARTIFACTCLASS)))),
         
         RAWMATERIAL = as.factor(
           ifelse(RAWMATERIAL == "Silcrete flake", "Silcrete",
                              ifelse(RAWMATERIAL == "OTHER", "Other",
                                     RAWMATERIAL))),
         
         CORTEX = ifelse(CORTEX == "10-40%", "11-40%",
                  ifelse(CORTEX == "90-99%", "91-99%",
                  ifelse(CORTEX == "60-90%", "61-90%",
                  ifelse(CORTEX == "40-60%", "41-60%",
                         CORTEX))))) |>
  
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete"),
         CORTEX != "\\",
         MAXWIDTH < 1250,
         MASS < 300)


# take average core flake scar length
df |>
  dplyr::filter(ARTIFACTCLASS=="Core") |>
  group_by(RAWMATERIAL, STRAT) |>
  summarize(Ave_FlakeLength = mean(LENGHTLONGESTFLAKESCAR)) -> core_size


# Subset data by flakes and flake variables
core_bind <- full_join(core_size, df) |>
  filter(ARTIFACTCLASS == "Flake" & COMPLETENESS == "Complete") |>
  group_by(RAWMATERIAL, STRAT) |>
  mutate(Utility1 = TECHLENGTH*(TECHLENGTH - 0.5),
         Utility2 = TECHLENGTH*(TECHLENGTH - 1),
         Utility3 = TECHLENGTH*(TECHLENGTH - 1.5),
         Utility4 = TECHLENGTH*(TECHLENGTH - 2),
         Utility5 = TECHLENGTH*(TECHLENGTH - 2.5),
         Utility6 = TECHLENGTH*(TECHLENGTH - 3),
         Utility7 = TECHLENGTH*(TECHLENGTH - 3.5),
         Utility8 = TECHLENGTH*(TECHLENGTH - 4),
         Utility9 = TECHLENGTH*(TECHLENGTH - 4.5),
         Utility10 = TECHLENGTH*(TECHLENGTH - 5),
         Utility11 = TECHLENGTH*(TECHLENGTH - 5.5),
         Utility12 = TECHLENGTH*(TECHLENGTH - 6),
         Utility13 = TECHLENGTH*(TECHLENGTH - 6.5),
         Utility14 = TECHLENGTH*(TECHLENGTH - 7),
         
         Reduction = TECHLENGTH/Ave_FlakeLength) |>
  
  select(any_of(names(df_students)), c(Utility1:Reduction)) -> df.flakes

# Subset data by cores and core variables
df.cores <- df |>
  filter(ARTIFACTCLASS == "Core" & CORECOMPLETENESS == "Complete") |>
  select(1:10,21:28,61:70) |>
  mutate(SA_Ellipse = (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)))

# Subset data by retouch and retouch variables
df.retouch <- df |>
  filter(ARTIFACTCLASS == "RetouchedTool" & RAWMATERIAL != "BWA UPPER 1" &
           COMPLETENESS == "Complete") |>
  select(1:11,21:27,29:60)

# Read tabulated data from previous publications (i.e. Jerardino & Yates)
sbf_df <- read.csv("../data/SBF_ToolType.csv")
sbf_un <- read.csv("../data/SBF_ToolType_unmod.csv")
```

## Raw material distribution

```{r tab1}
#| label: tab-one


# Create summary table

df |>
  mutate(across(where(is.factor), droplevels)) |>
  select(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS ==
                                  "RetouchedTool", "Retouched tools", ARTIFACTCLASS),
         RAWMATERIAL = 
           fct_relevel(RAWMATERIAL,
                       "Quartz", "Quartzite", "Silcrete")) |>
  rename(Layer = STRAT,
         `Artifact class` = ARTIFACTCLASS) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  tbl_strata(
    strata = RAWMATERIAL,
    .tbl_fun =
      ~ .x |>
        tbl_summary(by = "Artifact class", missing = "no") |> add_n()
  ) |>
  modify_header(label = "") -> tab1
tab1

#gtsave(tab1, "Table1.png")
```

```{r RMGGplot}
#| message: false
#| warning: false

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Layer",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  guides(fill = "none")+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1)))) -> RM_plot1

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT_mod, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT_mod, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1)),
                       angle = 45, hjust = 1)) -> RM_plot2

```

```{r fig-Figure5}

png("../results/figures/fig5.png", width = 290, height = 120, units = "mm", res = 300)
ggarrange(
  RM_plot2, RM_plot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)

dev.off()

```

```{r}

# chi square and fisher's exact test for proportion of artifact class by strat
df |>
  count(STRAT, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  group_by(RAWMATERIAL) |> # 1: Quartz 2: Quartzite; 3: Silcrete
  group_map(~ {
    tbl <- .x |>
      column_to_rownames(var = "STRAT") |>
      as.matrix()
      test <- contingencyTableBF(tbl,
                                 sampleType = "indepMulti",
                                 fixedMargin = "rows")

  })

contingencyTableBF(tbl, sampleType = "indepMulti", fixedMargin = "rows")
# chi square and fisher's exact test for proportion of artifact class by strat_mod
df |>
  count(STRAT_mod, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  group_by(RAWMATERIAL) |> # 1: Quartz 2: Quartzite; 3: Silcrete
  group_map(~ {
    tbl <- .x |>
      column_to_rownames(var = "STRAT_mod") |>
      as.matrix()
      test <- pairwise.prop.test(tbl)
      tibble(
        comparison = test$Comparison,
        Adj.chisq = test$p.adj.Chisq,
        Adj.fisher = test$p.adj.Fisher
      )

  })



fit_prop <- df |>
  filter(RAWMATERIAL == "Quartz") |>
  count(STRAT_mod, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  mutate(total = Core+Flake+RetouchedTool,
         y = cbind(Core, Flake, RetouchedTool))
  
fit_prop$size = with(fit_prop, Core + Flake + RetouchedTool)
fit_prop$y = with(fit_prop, cbind(Core, Flake, RetouchedTool))



fit <- brm(bf(y | trials(size)  ~ 1), data = fit_prop, 
                family = multinomial())








prior <- prior(normal(0, 10), "b", dpar = muy2) +
    prior(cauchy(0, 1), "Intercept") +
    prior(normal(0, 2), "Intercept", dpar = muy3)

bform1 <- 
  bf(mvbind(Flake, Core, RetouchedTool) ~ STRAT_mod) +
  set_rescor(TRUE)

fit_mat <- fit_prop |>
  select(Flake, Core, RetouchedTool) |>
  as.matrix()



prop_fit1 <- brm(
  ARTIFACTCLASS ~ STRAT_mod,
  data = df[which(df$RAWMATERIAL=="Quartz"),],
  family = categorical(),
  #prior = priors,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 2,
  iter = 3000,
  warmup = 1000,
)

draws_prop <- prop_fit1 |> 
  epred_draws(newdata = df[which(df$RAWMATERIAL=="Quartz"),])

draws_logit <- prop_fit1|>
  # This gives us counts...
  epred_draws(newdata = fit_prop)
  # ...so divide by the original total to get proportions again
  mutate(.epred_prop = .epred / total)

draws_logit |>
  ggplot(aes(x = .epred_prop, y = STRAT_mod, fill = STRAT_msod)) +
  stat_halfeye() +
  scale_x_continuous(labels = label_percent()) +
  #scale_fill_manual(values = c(clr_usa, clr_mex)) +
  guides(fill = "none") +
  labs(x = "Proportion of students who read comic books often",
       y = NULL)




###################
library(MCMCpack)

# Prior: uniform Dirichlet
alpha <- c(1,1,1)

# Sample posterior for time 1
p_time1 <- rdirichlet(10000, fit_prop$y[1,] + alpha) # coastal
p_time2 <- rdirichlet(10000, fit_prop$y[2,] + alpha) # mixed
p_time3 <- rdirichlet(10000, fit_prop$y[3,] + alpha) # terrestrial

# Difference between categories
diff1 <- p_time2 - p_time1
diff2 <- p_time3 - p_time1
diff3 <- p_time3 - p_time2

# Probability each category increased
apply(diff1, 2, function(x) mean(x > 0))
apply(diff2, 2, function(x) mean(x > 0))
apply(diff3, 2, function(x) mean(x > 0))






c <- tibble(counts = c(62, 454, 74,
                       88, 953, 116),
            STRAT = c(rep("Coastal", 3),
                      rep("Mixed", 3)))

    fit_proportions <- brm(
      counts ~ 1 + STRAT, # Intercept-only model for proportions
      data = c,
      family = dirichlet(), # Using identity link for proportions
      #prior = priors,
      chains = 1, # Number of MCMC chains
      iter = 2000, # Number of iterations per chain
      warmup = 1000 # Warmup iterations
    )
```

```{r CortexGGplot}
#| warning: false
#| message: false

# calculate the cortical to noncortical ratio based on percent of cortex and artifact surface area
iter = 100
df_cortex_boot <- tibble(STRAT = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(1234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95, 1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}


# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  
  
  
# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT, y = median, fill = RAWMATERIAL))+
  geom_bar(data = df_emp_cortex, aes(x = STRAT, y = ratio, fill = RAWMATERIAL),
           stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Layer",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot1
  
################## Bootstrap for modified Strats #####################
iter = 100
df_cortex_boot <- tibble(STRAT_mod = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT_mod, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}

# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  

# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT_mod) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT_mod, y = median, fill = RAWMATERIAL))+
  geom_bar(stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot2

rm(df_cortex_boot)
```

```{r fig-Figure6}

png("../results/figures/fig6.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  cort_plot2, cort_plot1,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r AllMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
# filter by values that caused errors in the models
fit_df <-df |>
      group_by(RAWMATERIAL) |>
      filter(!(RAWMATERIAL == "Silcrete" & MASS > 100) &
               !(RAWMATERIAL == "Quartzite" & MASS > 170)) |>
      mutate(log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,1), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,1), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,0.5), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+

  prior(gamma(1.1, 0.15), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(6,1), class = "Intercept")+
  
  prior(normal(4,1), class = "b", coef = "STRAT2")+
  prior(normal(4,1), class = "b", coef = "STRAT3")+
  prior(normal(3,1), class = "b", coef = "STRAT4a")+
  prior(normal(3,1), class = "b", coef = "STRAT4b")+
  prior(normal(3,1), class = "b", coef = "STRAT5")+
  
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(5,1), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(5,1), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(4,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(4,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(1.1, 0.15), class = "shape")
```

```{r fitAllMass}
fit_mass_all_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325777
)

fit_mass_all_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325778
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_mass_all_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_all_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_all_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_mass_all_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_all_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_mass_all_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_mass_all_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_mass_all_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_mass_all_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_all_ind, moment_match = T)
plot(loo1)
```

### Supp 1-2

```{r tab-AllMassGroup}
emmeans_res <- emmeans(fit_mass_all_grouped, ~ STRAT_mod*RAWMATERIAL,
                       type = "link")

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

#plot(emmeans_res)
supp_tab1 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI` < 0) | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 1. Posterior Estimate of the marginal means for the mass of all lithics conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab1, "../results/tables/Supp1.png")



```

```{r}
#| include: false

fit_df |>
  group_by(STRAT_mod) |>
  summarize(q75 = quantile(log(MASS), 0.75)) |>
  slice(rep(1:n(), each = 3)) |>
  mutate(RAWMATERIAL = rep(c("Quartz", "Quartzite", "Silcrete"), 3)) -> q75

c = 1
for(i in q75$q75){
  
  if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT_mod[c] == "Coastal"){
    hyp = paste0("Intercept < ",i)
  }
  else if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT_mod[c] != "Coastal"){
    hyp = paste0("Intercept + STRAT_mod",q75$STRAT_mod[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT_mod[c] == "Coastal"){
    hyp = paste0("Intercept + RAWMATERIAL",q75$RAWMATERIAL[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT_mod[c] != "Coastal"){
    hyp = paste0("Intercept + STRAT_mod", q75$STRAT_mod[c],
                 " + RAWMATERIAL", q75$RAWMATERIAL[c],
                   " + STRAT_mod", q75$STRAT_mod[c],
                 ":RAWMATERIAL", q75$RAWMATERIAL[c],
                 " < ",i)
  }
  
  h <- hypothesis(fit_mass_all_grouped, hyp)
  print(paste("Hypothesis for", hyp, "is", h$hypothesis$Post.Prob))
  
  c = c + 1
}

```

```{r tab-AllMassInd}
emmeans_res <- emmeans(fit_mass_all_ind, ~ STRAT*RAWMATERIAL,
                       type = "response")

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)


plot(emmeans_res)
supp_tab2 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 2. Posterior Estimate of the marginal means for the mass of all lithics conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab2, "../results/tables/Supp2.png")

```

```{r}
#| include: false

fit_df |>
  group_by(STRAT) |>
  summarize(q75 = quantile(log(MASS), 0.75)) |>
  slice(rep(1:n(), each = 3)) |>
  mutate(RAWMATERIAL = rep(c("Quartz", "Quartzite", "Silcrete"), 6)) -> q75

c = 1
for(i in q75$q75){
  
  if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT[c] == "1"){
    hyp = paste0("Intercept < ",i)
  }
  else if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT[c] != "1"){
    hyp = paste0("Intercept + STRAT",q75$STRAT[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT[c] == "1"){
    hyp = paste0("Intercept + RAWMATERIAL",q75$RAWMATERIAL[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT[c] != "1"){
    hyp = paste0("Intercept + STRAT", q75$STRAT[c],
                 " + RAWMATERIAL", q75$RAWMATERIAL[c],
                   " + STRAT", q75$STRAT[c],
                 ":RAWMATERIAL", q75$RAWMATERIAL[c],
                 " < ",i)
  }
  
  h <- hypothesis(fit_mass_all_ind, hyp)
  print(paste("Hypothesis for", hyp, "is", h$hypothesis$Post.Prob))
  
  c = c + 1
}

# Remove models to expand storage space in R environment
rm(fit_mass_all_grouped)
rm(fit_mass_all_ind)
```

```{r AllMassGGplot}

df |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  mutate(STRAT_mod = as.factor(STRAT_mod),
         RAWMATERIAL = as.factor(RAWMATERIAL)) |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+

  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["QUant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Grouped Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot2



```

```{r fig-Figure7}

png("../results/figures/fig7.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Art_mass_freqPlot1,Art_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
fit_df <- df |>
    select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS, STRAT_mod) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL),
           log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(1, 0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(2,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(1,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")
```

```{r CoreMassBayesMods}
fit_mass_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257777
)

fit_mass_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257788
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_mass_core_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_core_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_core_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_mass_core_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_core_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_mass_core_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_mass_core_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_mass_core_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_mass_core_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_core_ind, moment_match = T)
plot(loo1)
```

### Supp 3-4

```{r tab-CoreMassGroup}
#| warning: false
#| message: false
#| error: false


emmeans_res <- emmeans(fit_mass_core_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab3 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 3. Posterior Estimate of the marginal means for the mass of core tools conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab3, "../results/tables/Supp3.png")
```

```{r tab-CoreMassInd}
emmeans_res <- emmeans(fit_mass_core_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab4 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 4. Posterior Estimate of the marginal means for the mass of core tools conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab4, "../results/tables/Supp4.png")
```

```{r}
# Remove models to expand storage space in R environment
rm(fit_mass_core_grouped)
rm(fit_mass_core_ind)
```

```{r CoreMassGGplot}
#| warning: false
#| message: false
df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Grouped Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot2
```

```{r fig-Figure8}

png("../results/figures/fig8.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_mass_freqPlot1, Core_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreLength}
# Looking only at core Mass
fit_df <- df |>
    select(MASS, STRAT, STRAT_mod, RAWMATERIAL, MAXLENGTH, ARTIFACTCLASS) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL))


# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(18),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  
  prior(normal(3,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(18),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(0.5,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

```

```{r CoreLengthBayesMods}
fit_length_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557777
)

fit_length_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537788
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_length_core_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_length_core_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_length_core_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_length_core_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_length_core_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_length_core_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_length_core_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_length_core_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_length_core_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_length_core_ind, moment_match = T)
plot(loo1)
```

### Supp 5-6

```{r tab-CoreLengthGroup}
emmeans_res <- emmeans(fit_length_core_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

#plot(emmeans_res)

supp_tab5 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 5. Posterior Estimate of the marginal means for the maximum core length conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab5, "../results/tables/Supp5.png")
```

```{r tab-CoreLengthInd}
emmeans_res <- emmeans(fit_length_core_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab6 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 6. Posterior Estimate of the marginal means for the maximum core length conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab6, "../results/tables/Supp6.png")
```

```{r}
# Remove models to expand storage space in R environment
rm(fit_length_core_grouped)
rm(fit_length_core_ind)
```

```{r CoreLengthGGplot}
#| warning: false
#| message: false

df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, MAXLENGTH, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(MAXLENGTH, probs = 0.75),
         Median_mid50 = quantile(MAXLENGTH, probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  ggplot(aes(x = STRAT_mod, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
  xlab("Grouped Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "lightblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot2
```

```{r fig-Figure9}

png("../results/figures/fig9.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_length_freqPlot1, Core_length_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

## Toolkit composition

```{r fig-Figure10}

png("../results/figures/fig10.png", width = 180, height = 120,
    units = "mm", res = 300)
# Data pulled from Jerardino, 2022
sbf_df |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
  group_by(Layer) |>
  summarize(Tool_sum = sum(Count)) |>
  mutate(Lithic_Dens = c(602.7, 850.9,
                         ((819+1861)/((819/1863.6)+(1861/1094.7))),
                         2904.3, 1545.6, 2788.5),
         Dep_rate = abs(c(((2.45+2)/2)-((2.6+2.2)/2),
                      ((2.6+2.2)/2)-((3+2.4)/2),
                      ((3+2.4)/2)-((3.5+2.7)/2),
                      ((3.5+2.7)/2)-((5+3)/2),
                      ((5+3)/2)-(4.6),
                      ((9.7+4.6)/2)-(9.7)))) |>
  left_join(
    
    sbf_un |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
      group_by(Layer) |>
      summarize(Deb_sum = sum(Count)) 
    
) |>
  mutate(Tool_Perc = (Tool_sum/Deb_sum)*100,
         Lithic_std = Lithic_Dens/Dep_rate) |>
  
  ggplot(aes(x = Lithic_std, y = Tool_Perc, color = Layer, label = Layer))+
  geom_point(size = 3)+
  geom_text(aes(fontface = 2),hjust = 1.5, vjust = 0, size = 5)+
  xlab("Lithic Density/Deposition Rate")+ylab("Formal Tool Percent")+
  theme_minimal()+
  theme(text = element_text(size = 20))+
  guides(color = "none")+
  scale_color_manual(values = c("1" = "skyblue", "2" = "skyblue", "3" = "skyblue",
                                "4a" ="darkcyan", "4b" = "darkcyan",
                                "5" = "lightgreen"))

dev.off()
```

## Flake utility and reduction intensity

### Grouped Layers

```{r}
# Gamma prior
my_prior <-

  # Intercept
  prior(normal(0, 1), class = Intercept)+
  
  # Polynomial factor 1
  prior(normal(0, 1), class = b, coef = "polyReduction_s21")+

  # Polynomial factor 2
  prior(normal(0, 0.5), class = b, coef = "polyReduction_s22")+

  # Group-level SDs
  prior(exponential(1), class = sd)+

  # Gamma shape
  prior(exponential(1), class = shape)


  
  
# Run Bayesian model with varying slopes
bayes_ut1 <- brm(Utility_s ~ 1 + poly(Reduction_s, 2) +
                   (0 + poly(Reduction_s, 2) | STRAT_mod/RAWMATERIAL),
              data = Bayes_red1,
              family = Gamma(link = "log"),
              iter = 4000,
              chains = 2,
              seed = 111,
              control = list(adapt_delta = 0.95),
              prior=my_prior,
              cores = getOption("mc.cores", 14))

```

```{r}
# Validate model with posterior checks

pp_check(bayes_ut1, type = "dens_overlay")
pp_check(bayes_ut1, type = "stat")

pp_check(bayes_ut1, type = "scatter_avg_grouped", group = "RAWMATERIAL")
pp_check(bayes_ut1, type = "scatter_avg_grouped", group = "STRAT_mod")



loo1 <- loo(bayes_ut1)
plot(loo1)
```

```{r}
x_seq <- seq(min(Bayes_red1$Reduction_s, na.rm = TRUE),
             max(Bayes_red1$Reduction_s, na.rm = TRUE),
             length.out = 100)

# All combinations of grouping levels
newdat <- expand_grid(
  Reduction_s = x_seq,
  STRAT_mod = unique(Bayes_red1$STRAT_mod),
  RAWMATERIAL = unique(Bayes_red1$RAWMATERIAL)
)

# Get fitted values (posterior draws of the mean)
preds <- fitted(
  bayes_ut1,       # your Gamma(log) model
  newdata = newdat,
  re_formula = NULL,    # include group-level effects
  summary = FALSE       # return full posterior draws
)

# Add to the grid and summarize
pred_summary <- newdat |>
  bind_cols(as_tibble(t(preds))) |>
  pivot_longer(cols = starts_with("V"), values_to = "Utility_pred") |>
  group_by(STRAT_mod, RAWMATERIAL, Reduction_s) |>
  summarise(
    mean = mean(Utility_pred),
    lower = quantile(Utility_pred, 0.025),
    upper = quantile(Utility_pred, 0.975),
    .groups = "drop"
  )


ggplot(pred_summary, aes(x = Reduction_s, y = mean, color = STRAT_mod)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = STRAT_mod), alpha = 0.2, color = NA) +
  facet_wrap(~ RAWMATERIAL, scales = "free_y") +
  labs(
    title = "Predicted Utility by Reduction level",
    subtitle = "Posterior mean and 95% credible interval per Raw Material and Strat Category",
    x = "Reduction (standardized)",
    y = "Predicted Utility"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")

```

```{r}
# Assign sequence to procude slope values
x_seq <- seq(min(Bayes_red1$Reduction_s),
             max(Bayes_red1$Reduction_s),
             length.out = 50)

# Group specific slopes
post <- spread_draws(
  bayes_ut1,
  b_polyReduction_s21, b_polyReduction_s22,
  # Quartz
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`,
  
  # Quartzite
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`,
  
  # Silcrete
  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`
)

# Determine the optimal surplus based on where tangent = 0
post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    # Quartz
    x_Quartz_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)),
    
    x_Quartz_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)),
    
    x_Quartz_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)),
    
    # QUartzite
    x_Quartzite_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`)),
    
    x_Quartzite_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`)),
    
    x_Quartzite_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`)),
    
    # Silcrete
    x_Silcrete_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`)),
    
    x_Silcrete_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`)),
    
    x_Silcrete_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`)),
  ) |>
  
  
  select(starts_with("x")) |>
  pivot_longer(x_Quartz_C:x_Silcrete_T,
               names_to = "layer", values_to = "x_value") |>

  ggplot(aes(x = x_value, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.95,
               point_interval = mean_qi) +
  scale_fill_manual(
    values = c("x_Quartz_T" = "forestgreen",
               "x_Quartz_M" = "darkmagenta",
               "x_Quartz_C" = "skyblue",
               
               "x_Quartzite_T" = "forestgreen",
               "x_Quartzite_M" = "darkmagenta",
               "x_Quartzite_C" = "skyblue",
               
               "x_Silcrete_T" = "forestgreen",
               "x_Silcrete_M" = "darkmagenta",
               "x_Silcrete_C" = "skyblue")) +
  
  
  labs(x = "Posterior Estimate for Reduction Intensity", y = "Group") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("x_Quartz_T" = "Quartz:Terrestrial",
               "x_Quartz_M" = "Quartz:Mixed",
               "x_Quartz_C" = "Quartz:Coastal",
               
               "x_Quartzite_T" = "Quartzite:Terrestrial",
               "x_Quartzite_M" = "Quartzite:Mixed",
               "x_Quartzite_C" = "Quartzite:Coastal",
               
               "x_Silcrete_T" = "Silcrete:Terrestrial",
               "x_Silcrete_M" = "Silcrete:Mixed",
               "x_Silcrete_C" = "Silcrete:Coastal")
  )
  
  

```

```{r}

# Compute slope values
slope_draws <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    slope_Quartz_C = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)*Reduction_s),
    
    slope_Quartz_M = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)*Reduction_s),
    
    slope_Quartz_T = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)*Reduction_s),
  )

# Summarize and visualize slopes
slope_summary <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_C:slope_Quartz_T, names_to = "groups", values_to = "slopes") |>
  group_by(groups, Reduction_s) |>
  summarise(
    mean = mean(slopes),
    lower = quantile(slopes, 0.025),
    upper = quantile(slopes, 0.975),
    .groups = "drop"
  )


ggplot(slope_summary, aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups), alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(y = "Instantaneous slope (d log(Utility)/d Reduction)",
       title = "Group-specific slope curves",
       color = "Group", fill = "Group") +
  theme_bw()

```

```{r}
# Test slope differences
compare_slope <- slope_draws |>
  mutate(diff1 = slope_Quartz_C - slope_Quartz_T,
         diff2 = slope_Quartz_C - slope_Quartz_T,
         diff3 = slope_Quartz_M - slope_Quartz_T,
         
         m1 = mean(diff1 > 0),
         m2 = mean(diff2 > 0),
         m3 = mean(diff3 > 0))

compare_slope |>
  select(m1:m3) |>
  distinct() |>
  print()


pairwise_diffs <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_C:slope_Quartz_T, names_to = "groups", values_to = "slopes") |>
  group_by(groups) |>
  summarise(mean_slope = mean(slopes),
            lower = quantile(slopes, 0.025),
            upper = quantile(slopes, 0.975))


```

```{r}
compare_slope |>
  select(starts_with("diff")) |>
  pivot_longer(diff1:diff3,
               names_to = "layer", values_to = "slope") |>
  
  ggplot(aes(x = slope, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.90,
               point_interval = mean_qi)
  scale_fill_manual(
    values = c("slope_Ter" = "forestgreen",
               "slope_Mix" = "darkmagenta",
               "slope_Aq" = "skyblue")) +
  
  
  labs(x = "Posterior Slope Estimate", y = "Phase") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 20),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("slope_Ter" = "Terrestrial",
               "slope_Mix" = "Mixed",
               "slope_Aq" = "Aquatic")
  )
```

### Old Junk

```{r fig-Figure11}

library(ggforce)
png("../results/figures/fig11.png", width = 180, height = 120,
    units = "mm", res = 300)

# Create elliptical confidence intervals
ellipse_data <- data.frame(
      x0 = 5,  # X-coordinate of the center
      y0 = 5,  # Y-coordinate of the center
      a = 2,   # Length of the major axis
      b = 1,   # Length of the minor axis
      angle = pi/4 # Angle of rotation in radians (e.g., 45 degrees)
)

df.flakes |>
  select(STRAT, STRAT_mod, RAWMATERIAL, Utility1, Reduction) |>
  group_by(STRAT, RAWMATERIAL) |>
  na.omit()|>
  summarize(Utility_ave = mean(Utility1),
            Red_ave = mean(Reduction),
            
            Utility_sd = sd(Utility1),
            Red_sd = sd(Reduction)) |>
  
  ggplot(aes(x = Red_ave, y = Utility_ave, 
                   color = STRAT, label = STRAT))+
    geom_point(size = 2)+
    geom_ellipse(aes(x0 = Red_ave, y0 = Utility_ave,
                     a = Red_sd, b = Utility_sd,
                     angle = 0))+
    facet_wrap(~RAWMATERIAL)+
    geom_text(aes(fontface = 2),hjust = 1.1, vjust = -0.2)+
  
  
    xlab("Reduction Intensity")+ylab("Flake Utility")+
    theme_light()+
    theme(legend.title = element_blank(), text = element_text(size = 15))+
    guides(color = "none")+
    scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                   "3" = "skyblue",
                                   "4a" = "darkcyan", "4b" = "darkcyan",
                                   "5" = "lightgreen"))

dev.off()
```

## Retouched flake utility to retouch intensity

```{r FlakeRetouch}
df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "MinimallyRetouched") |>
  mutate(Ratio =
           ((EDGETHICKNESS_1+EDGETHICKNESS_2+EDGETHICKNESS_3)/3)/MAXTHICKNESS,
         Region = RETOUCHREGIONNUMBER/8,
         Ratio = rescale(Ratio, to = c(0, 10)),
         Region = rescale(Region, to = c(0, 10))) |>
  select(STRAT, UNIT, RAWMATERIAL, Ratio, Region, MASS, MAXWIDTH, MAXLENGTH,
         MAXTHICKNESS, RETOUCHREGIONLOCATION, LENGTHLONGESTRETOUCH) -> ret_int

```

```{r fig-Figure12}

png("../results/figures/fig12.png", width = 180, height = 120,
    units = "mm", res = 300)

ret_int |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  summarize(Ratio_m = mean(Ratio), Region_m = mean(Region),
            MWidth = mean(MAXWIDTH), MLength = mean(MAXLENGTH)) |>
  ggplot(aes(x = (Ratio_m+Region_m)/2, y = MWidth*MLength, 
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  facet_wrap(~RAWMATERIAL)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Flake Retouch Intensity")+ylab("Flake Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Cores

```{r coreVolumeRemoved}
df.flakes |>
  select(RAWMATERIAL, STRAT, PLATFORMTHICKNESS, MAXTHICKNESS) |>
  group_by(RAWMATERIAL, STRAT) |>
  na.omit() |>
  summarize(m_plat = mean(PLATFORMTHICKNESS),
            m_thick = mean(MAXTHICKNESS)) |>
  arrange(STRAT, RAWMATERIAL) -> flake.vr

flake.vr |>
  left_join(df.cores) |>
  select(m_plat, m_thick,
         STRAT, RAWMATERIAL, MAXLENGTH, MAXWIDTH, MAXTHICKNESS,
         FLAKEGENERATIONSTHICKNESS, FLAKEGENERATIONSLENGTH, FLAKEGENERATIONSWIDTH,
         SA_Ellipse, SCARCOUNT) |>
  na.omit() |>
  group_by(RAWMATERIAL, STRAT) |>
  mutate(V = pi*(4/3)*(MAXLENGTH/2)*(MAXWIDTH/2)*(MAXTHICKNESS/2),
         VR = pi*(4/3)*((MAXLENGTH + (m_plat*FLAKEGENERATIONSLENGTH))/2)*
                       ((MAXWIDTH + (m_plat*FLAKEGENERATIONSWIDTH))/2)*
                       ((MAXTHICKNESS + (m_thick*FLAKEGENERATIONSTHICKNESS))/2),
         volume_removed = (V/VR)*100,
         
         SDI = SCARCOUNT/SA_Ellipse) |>
  select(STRAT, RAWMATERIAL, V, VR, volume_removed, SDI, SA_Ellipse)-> cores.vr
```

```{r fig-Figure13}
# Tells us:
# High reduction intensity and low utility is more mobile
# High reduction and high utility is sedentary but low reduction and high utility is fully sedentary?
# Low reduction intensity and low utility means not focused on flake production?

png("../results/figures/fig13.png", width = 180, height = 120,
    units = "mm", res = 300)

cores.vr |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(volume_ave = mean(V),
            sdi_ave = mean(SDI),
            volumeRec_mean = mean(volume_removed)) |>
  ggplot(aes(x = volumeRec_mean, y = log(volume_ave),
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  facet_grid(~RAWMATERIAL)+
  
  
  xlab("Core Reduction Intensity")+ylab("log-Core Utility")+
  theme_light()+
  theme(legend.title = element_blank(), 
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Scraper utility and retouch intensity

```{r scraperRetouchIntensity}
# Define a database for scraper retouch
df.scrap <- df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "SideScraper" | 
           RETOUCHEDPIECETYPOLOGY == "EndScraper" |
           RETOUCHEDPIECETYPOLOGY == "Side-EndScraper") |>
  select("SCRAPERRETOUCHHEIGHT1", "SCRAPERRETOUCHHEIGHT2", "SCRAPERRETOUCHHEIGHT3",
         "SCRAPERRETOUCHANGLE1", "SCRAPERRETOUCHANGLE2", "SCRAPERRETOUCHANGLE3",
         "SCRAPERDORSALANGLE1", "SCRAPERDORSALANGLE2", "SCRAPERDORSALANGLE3",
         "SCRAPERRETOUCHLENGTH",
         "SCRAPERMAXTHICKNESS",
         "MAXLENGTH", "MAXWIDTH",
         
         "RAWMATERIAL", "STRAT", "MASS") |>
  na.omit() |>
  mutate(RET_INT = round(((SCRAPERRETOUCHHEIGHT1+
                            SCRAPERRETOUCHHEIGHT2+
                            SCRAPERRETOUCHHEIGHT3)/SCRAPERMAXTHICKNESS)*
                           SCRAPERRETOUCHLENGTH,2),
         SA = MAXLENGTH*MAXWIDTH)


# Preprocess data to enter into custom function to calculate scraper reduction
scrap.red <- df.scrap |>
  na.omit() |>
  mutate(D = (SCRAPERRETOUCHHEIGHT1+SCRAPERRETOUCHHEIGHT2+SCRAPERRETOUCHHEIGHT3)/3,
         a = (SCRAPERRETOUCHANGLE1+SCRAPERRETOUCHANGLE2+SCRAPERRETOUCHANGLE3)/3,
         b = (SCRAPERDORSALANGLE1+SCRAPERDORSALANGLE2+SCRAPERDORSALANGLE3)/3) |>
  rename(L = SCRAPERRETOUCHLENGTH)

scrap.red <- scraper_red(scrap.red$L, scrap.red$D, scrap.red$a, scrap.red$b)/1000

scrap.red <- scrap.red |>
  mutate(RETOUCH = as.vector(scrap.red$Reduction),
         STRAT = df.scrap$STRAT,
         UTILITY = df.scrap$MAXWIDTH*df.scrap$MAXLENGTH,
         
         RAWMATERIAL = df.scrap$RAWMATERIAL,
         
         RE_Ut = UTILITY/Reduction,
         
         MASS = df.scrap$MASS)
```

```{r fig-Figure14}

png("../results/figures/fig14.png", width = 180, height = 120,
    units = "mm", res = 300)

scrap.red |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Silcrete")) |>
  summarize(Retouch_ave = mean(RETOUCH),
            Utility_ave = mean(UTILITY))|>
  ggplot(aes(x = Retouch_ave, y = Utility_ave, 
             color = STRAT, label = STRAT))+
  geom_point(size = 3)+
  facet_grid(~RAWMATERIAL)+
  geom_text(aes(fontface = 2.5),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Scraper Retouch Intensity")+ylab("Scraper Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 17))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Additional analysis on Adzes

```{r}
#| include: false

df_adze <- df |>
  as_tibble() |>
  filter(RETOUCHEDPIECETYPOLOGY == "Adze") |>
  select(STRAT, RAWMATERIAL, SCARCOUNT,
         MAXLENGTH, MAXWIDTH, MAXTHICKNESS, MASS) |>
  mutate(SA = 2*((MAXLENGTH*MAXWIDTH)+
                   (MAXTHICKNESS*MAXWIDTH)+
                   (MAXTHICKNESS*MAXLENGTH)),
         SDI = SA/SCARCOUNT)

df_adze |>
  ggplot(aes(x = STRAT, y = SDI))+
  geom_boxplot()

df_adze |>
  ggplot(aes(x = STRAT, y = log(MASS)))+
  geom_boxplot()

TukeyHSD(aov(lm(SDI~STRAT, data = df_adze)))
```
