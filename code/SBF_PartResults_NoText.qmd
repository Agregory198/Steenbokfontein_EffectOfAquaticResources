---
title: "Steenbokfontein Preliminary Results"
execute: 
  echo: false
  warning: false
  message: false
format: html
editor: visual
---

```{r library}
#| warning: false
#| message: false


# To plot figures
library(ggplot2)
library(forcats)
library(ggpubr)
library(ggridges)
library(cowplot)
library(ggforce)

library(infer)
#library(rcompanion)
library(purrr)
#library(rcompanion)
library(viridis)

library(scales)
library(stringr)

# To generate tables
library(gtsummary)
library(gt)
library(broom)
library(broom.mixed)

library(stargazer)
library(kableExtra)

# To tidy the data
library(tidyr)
library(tidyverse)
library(dplyr)
library(forcats)
library(tidybayes)

# Bayesian models
library(brms)
library(emmeans)
library(loo)
library(BayesFactor)
library(posterior)
```

```{r ScraperRetouchFormula}
# Calculate scraper retouch intensity
scraper_red <- function(L, D, a, b){
  
  t = D * sin(a)
  D3 = D * cos(a)
  D1 = t/(sin(b))
  D4 = (t * cos(b))/(sin(b))
  
  D2 = D4 - D3
  
  B = t * (sin(b)) # define base B to find height (which is also D1)
  
  h = sin(b) * ((t*(cos(b)/sin(b))) - (D*cos(a)))
  
  A =  0.5 * B * h# find values of area now
  
  RE = L*((D^2)/2)*((sin(a*(pi/180))^2 * 
                       (cos(b*(pi/180))/sin(b*(pi/180)))) - 
                      (sin(a*(pi/180)) * cos(a*(pi/180))))
  
  
  output <- tibble(Reduction = RE)
  
  return(output)
  
  
}
```

```{r ReadData}
#| message: false
#| warning: false

# Read and clean data
df_sum24 <- read.csv("../data/AG_Summer2024_SBF_Final.csv") |>
  select(-c('X')) |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"), "Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))

df_sum25 <- read.csv("../data/AG_Summer2025_SBF_Final.csv") |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  select(-c(X))

# student's dataframe
df_One <- read_csv("../data/DataSheet_1.csv")|>
  mutate(STRAT = tolower(Layer),
         
         PLATFORMWIDTH = parse_number("Platform Width"),
         PLATFORMTHICKNESS = parse_number("Platform Thickness"),
         MAXLENGTH = parse_number("Maximum Length"),
         TECHLENGTH = parse_number("Technological Length"),
         MAXWIDTH = parse_number("Maximum Width"),
         TECHWIDTH = parse_number("Technological Width"),
         MAXTHICKNESS = parse_number("Thickness"),
         MASS = parse_number("Mass"))

df_One <- df_One[1:289,]

df_One_flakes <- df_One |>
  
  add_column(OTHERUNIT = NA, .before = "Raw Material") |>

  rename(SITE = Site, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         CORTEXTYPE = `Cortex Origin`, ARTIFACTCLASS = `Artifact class`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = PlatformAbrasion, 
         STAGE = `Flaking Stage`) |>
  
  select(-c(Layer, Notes, Photo,
            `Platform Width`:`Platform Thickness`, `Maximum Length`:Mass)) |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                      ifelse(STRAT == "3b", "3", 
                             ifelse(STRAT == "5a", "5", STRAT))),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  relocate(STRAT, .before = "UNIT") |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  
  

# student's Dataframe
df_Two <- read_csv("../data/DataSheet_2.csv") |>
  
  rename(SITE = Site, STRAT = Layer, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         ARTIFACTCLASS = `Artifact class`, CORTEXTYPE = `Cortex Origin`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = `PlatformAbrasion`, PLATFORMWIDTH = `Platform Width`,
         PLATFORMTHICKNESS = `Platform Thickness`, STAGE = `Flaking Stage`,
         MAXLENGTH = `Maximum Length`, TECHLENGTH = `Technological Length`,
         MAXWIDTH = `Maximum Width`, TECHWIDTH = `Technological Width`,
         MAXTHICKNESS = Thickness, MASS = Mass) |>
  
  select(-c(`...2`,Notes:Photo))

df_Two_flakes <- df_Two |>
  
  add_column(OTHERUNIT = NA, .before = "RAWMATERIAL") |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                    ifelse(STRAT == "3b", "3", 
                           ifelse(STRAT == "5a", "5", STRAT))),
          STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))




df_Two_flakes <- df_Two_flakes[1:421,] |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  

df_students <- rbind(df_Two_flakes, df_One_flakes)


df <- rbind(df_sum24, df_sum25) |>
  merge(df_students, all = T) |>
  mutate(TECHLENGTH = as.numeric(TECHLENGTH),
         MAXWIDTH = as.numeric(MAXWIDTH),
         MAXTHICKNESS = as.numeric(MAXTHICKNESS)) |>
  filter(STRAT %in% c("1", "2", "3", "4a", "4b", "5")) |>
  
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS == "flake", "Flake",
                         ifelse(ARTIFACTCLASS == "blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Flake/Blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Fragment", "Flake",
                                                     ARTIFACTCLASS)))),
         
         RAWMATERIAL = as.factor(
           ifelse(RAWMATERIAL == "Silcrete flake", "Silcrete",
                              ifelse(RAWMATERIAL == "OTHER", "Other",
                                     RAWMATERIAL))),
         
         CORTEX = ifelse(CORTEX == "10-40%", "11-40%",
                  ifelse(CORTEX == "90-99%", "91-99%",
                  ifelse(CORTEX == "60-90%", "61-90%",
                  ifelse(CORTEX == "40-60%", "41-60%",
                         CORTEX))))) |>
  
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete"),
         CORTEX != "\\",
         MAXWIDTH < 1250,
         MASS < 300)


# take average core flake scar length
df |>
  dplyr::filter(ARTIFACTCLASS=="Core") |>
  group_by(RAWMATERIAL, STRAT) |>
  summarize(Ave_FlakeLength = mean(LENGHTLONGESTFLAKESCAR)) -> core_size


# set values for small, medium, and large slug effect sizes
df |> 
  filter(TECHLENGTH != 0 & !is.na(TECHLENGTH)) |> 
  summarize(m = min(TECHLENGTH)) -> small
small <- small$m

df |> 
  filter(TECHLENGTH != 0 & !is.na(TECHLENGTH)) |> 
  summarize(m = quantile(TECHLENGTH, c(0.05), na.rm = T)) -> medium
medium <- medium$m

df |> 
  filter(TECHLENGTH != 0 & !is.na(TECHLENGTH)) |> 
  summarize(m = quantile(TECHLENGTH, c(0.1), na.rm = T)) -> large
large <- large$m


# Subset data by flakes and flake variables
core_bind <- full_join(core_size, df) |>
  filter(ARTIFACTCLASS == "Flake" & COMPLETENESS == "Complete") |>
  group_by(RAWMATERIAL, STRAT) |>
  mutate(Utility_small = TECHLENGTH*(TECHLENGTH - small),
         Utility_mid = TECHLENGTH*(TECHLENGTH - medium),
         Utility_large = TECHLENGTH*(TECHLENGTH - large),
         
         Transport_small = Utility_small/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3),
         Transport_mid = Utility_mid/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3),
         Transport_large = Utility_large/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3),
         
         Reduction = TECHLENGTH/Ave_FlakeLength) |>
  
  select(any_of(names(df_students)), c(Utility_small:Reduction)) -> df.flakes

# Subset data by cores and core variables
df.cores <- df |>
  filter(ARTIFACTCLASS == "Core" & CORECOMPLETENESS == "Complete") |>
  select(1:10,21:28,61:70) |>
  mutate(SA_Ellipse = (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)))

# Subset data by retouch and retouch variables
df.retouch <- df |>
  filter(ARTIFACTCLASS == "RetouchedTool" & RAWMATERIAL != "BWA UPPER 1" &
           COMPLETENESS == "Complete") |>
  mutate(Utility_small = TECHLENGTH*(TECHLENGTH - small),
         Utility_mid = TECHLENGTH*(TECHLENGTH - medium),
         Utility_large = TECHLENGTH*(TECHLENGTH - large),
         
         Transport_small = Utility_small/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3),
         Transport_mid = Utility_mid/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3),
         Transport_large = Utility_large/((MAXTHICKNESS/TECHLENGTH)*TECHLENGTH^3)) |>
  select(1:11,21:27,29:60, Utility_small:Transport_large)

# Read tabulated data from previous publications (i.e. Jerardino & Yates)
sbf_df <- read.csv("../data/SBF_ToolType.csv")
sbf_un <- read.csv("../data/SBF_ToolType_unmod.csv")
```

## Raw material distribution

```{r tab1}
#| label: tab-one


# Create summary table

df |>
  mutate(across(where(is.factor), droplevels)) |>
  select(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS ==
                                  "RetouchedTool", "Retouched tools", ARTIFACTCLASS),
         RAWMATERIAL = 
           fct_relevel(RAWMATERIAL,
                       "Quartz", "Quartzite", "Silcrete")) |>
  rename(Layer = STRAT,
         `Artifact class` = ARTIFACTCLASS) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  tbl_strata(
    strata = RAWMATERIAL,
    .tbl_fun =
      ~ .x |>
        tbl_summary(by = "Artifact class", missing = "no") |> add_n()
  ) |>
  modify_header(label = "") -> tab1
tab1

#gtsave(tab1, "Table1.png")
```

```{r RMGGplot}
#| message: false
#| warning: false

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Layer",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  guides(fill = "none")+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1)))) -> RM_plot1

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT_mod, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT_mod, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1)),
                       angle = 45, hjust = 1)) -> RM_plot2

```

```{r fig-Figure5}

png("../results/figures/fig5.png", width = 290, height = 120, units = "mm", res = 300)
ggarrange(
  RM_plot2, RM_plot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)

dev.off()

```

```{r}

# chi square and fisher's exact test for proportion of artifact class by strat
df |>
  count(STRAT, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  group_by(RAWMATERIAL) |> # 1: Quartz 2: Quartzite; 3: Silcrete
  group_map(~ {
    tbl <- .x |>
      column_to_rownames(var = "STRAT") |>
      as.matrix()
      test <- contingencyTableBF(tbl,
                                 sampleType = "indepMulti",
                                 fixedMargin = "rows")

  })

contingencyTableBF(tbl, sampleType = "indepMulti", fixedMargin = "rows")
# chi square and fisher's exact test for proportion of artifact class by strat_mod
df |>
  count(STRAT_mod, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  group_by(RAWMATERIAL) |> # 1: Quartz 2: Quartzite; 3: Silcrete
  group_map(~ {
    tbl <- .x |>
      column_to_rownames(var = "STRAT_mod") |>
      as.matrix()
      test <- pairwise.prop.test(tbl)
      tibble(
        comparison = test$Comparison,
        Adj.chisq = test$p.adj.Chisq,
        Adj.fisher = test$p.adj.Fisher
      )

  })



fit_prop <- df |>
  filter(RAWMATERIAL == "Quartz") |>
  count(STRAT_mod, ARTIFACTCLASS, RAWMATERIAL) |>
  pivot_wider(names_from = ARTIFACTCLASS, values_from = n, values_fill = 0) |>
  mutate(total = Core+Flake+RetouchedTool,
         y = cbind(Core, Flake, RetouchedTool))
  
fit_prop$size = with(fit_prop, Core + Flake + RetouchedTool)
fit_prop$y = with(fit_prop, cbind(Core, Flake, RetouchedTool))



fit <- brm(bf(y | trials(size)  ~ 1), data = fit_prop, 
                family = multinomial())








prior <- prior(normal(0, 10), "b", dpar = muy2) +
    prior(cauchy(0, 1), "Intercept") +
    prior(normal(0, 2), "Intercept", dpar = muy3)

bform1 <- 
  bf(mvbind(Flake, Core, RetouchedTool) ~ STRAT_mod) +
  set_rescor(TRUE)

fit_mat <- fit_prop |>
  select(Flake, Core, RetouchedTool) |>
  as.matrix()



prop_fit1 <- brm(
  ARTIFACTCLASS ~ STRAT_mod,
  data = df[which(df$RAWMATERIAL=="Quartz"),],
  family = categorical(),
  #prior = priors,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 2,
  iter = 3000,
  warmup = 1000,
)

draws_prop <- prop_fit1 |> 
  epred_draws(newdata = df[which(df$RAWMATERIAL=="Quartz"),])

draws_logit <- prop_fit1|>
  # This gives us counts...
  epred_draws(newdata = fit_prop)
  # ...so divide by the original total to get proportions again
  mutate(.epred_prop = .epred / total)

draws_logit |>
  ggplot(aes(x = .epred_prop, y = STRAT_mod, fill = STRAT_msod)) +
  stat_halfeye() +
  scale_x_continuous(labels = label_percent()) +
  #scale_fill_manual(values = c(clr_usa, clr_mex)) +
  guides(fill = "none") +
  labs(x = "Proportion of students who read comic books often",
       y = NULL)




###################
library(MCMCpack)

# Prior: uniform Dirichlet
alpha <- c(1,1,1)

# Sample posterior for time 1
p_time1 <- rdirichlet(10000, fit_prop$y[1,] + alpha) # coastal
p_time2 <- rdirichlet(10000, fit_prop$y[2,] + alpha) # mixed
p_time3 <- rdirichlet(10000, fit_prop$y[3,] + alpha) # terrestrial

# Difference between categories
diff1 <- p_time2 - p_time1
diff2 <- p_time3 - p_time1
diff3 <- p_time3 - p_time2

# Probability each category increased
apply(diff1, 2, function(x) mean(x > 0))
apply(diff2, 2, function(x) mean(x > 0))
apply(diff3, 2, function(x) mean(x > 0))






c <- tibble(counts = c(62, 454, 74,
                       88, 953, 116),
            STRAT = c(rep("Coastal", 3),
                      rep("Mixed", 3)))

    fit_proportions <- brm(
      counts ~ 1 + STRAT, # Intercept-only model for proportions
      data = c,
      family = dirichlet(), # Using identity link for proportions
      #prior = priors,
      chains = 1, # Number of MCMC chains
      iter = 2000, # Number of iterations per chain
      warmup = 1000 # Warmup iterations
    )
```

```{r CortexGGplot}
#| warning: false
#| message: false

# calculate the cortical to noncortical ratio based on percent of cortex and artifact surface area
iter = 100
df_cortex_boot <- tibble(STRAT = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(1234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95, 1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}


# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  
  
  
# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT, y = median, fill = RAWMATERIAL))+
  geom_bar(data = df_emp_cortex, aes(x = STRAT, y = ratio, fill = RAWMATERIAL),
           stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Layer",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot1
  
################## Bootstrap for modified Strats #####################
iter = 100
df_cortex_boot <- tibble(STRAT_mod = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT_mod, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}

# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  

# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT_mod) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT_mod, y = median, fill = RAWMATERIAL))+
  geom_bar(stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot2

rm(df_cortex_boot)
```

```{r fig-Figure6}

png("../results/figures/fig6.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  cort_plot2, cort_plot1,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r AllMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
# filter by values that caused errors in the models
fit_df <-df |>
      group_by(RAWMATERIAL) |>
      filter(!(RAWMATERIAL == "Silcrete" & MASS > 100) &
               !(RAWMATERIAL == "Quartzite" & MASS > 170)) |>
      mutate(log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,1), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,1), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,0.5), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+

  prior(gamma(1.1, 0.15), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(6,1), class = "Intercept")+
  
  prior(normal(4,1), class = "b", coef = "STRAT2")+
  prior(normal(4,1), class = "b", coef = "STRAT3")+
  prior(normal(3,1), class = "b", coef = "STRAT4a")+
  prior(normal(3,1), class = "b", coef = "STRAT4b")+
  prior(normal(3,1), class = "b", coef = "STRAT5")+
  
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(5,1), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(5,1), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(4,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(4,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(1.1, 0.15), class = "shape")
```

```{r fitAllMass}
fit_mass_all_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325777
)

fit_mass_all_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325778
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_mass_all_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_all_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_all_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_mass_all_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_all_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_mass_all_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_mass_all_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_mass_all_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_mass_all_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_all_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_all_ind, moment_match = T)
plot(loo1)
```

### Supp 1-2

```{r tab-AllMassGroup}
emmeans_res <- emmeans(fit_mass_all_grouped, ~ STRAT_mod*RAWMATERIAL,
                       type = "link")

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

#plot(emmeans_res)
supp_tab1 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI` < 0) | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 1. Posterior Estimate of the marginal means for the mass of all lithics conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab1, "../results/tables/Supp1.png")



```

```{r}
#| include: false

fit_df |>
  group_by(STRAT_mod) |>
  summarize(q75 = quantile(log(MASS), 0.75)) |>
  slice(rep(1:n(), each = 3)) |>
  mutate(RAWMATERIAL = rep(c("Quartz", "Quartzite", "Silcrete"), 3)) -> q75

c = 1
for(i in q75$q75){
  
  if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT_mod[c] == "Coastal"){
    hyp = paste0("Intercept < ",i)
  }
  else if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT_mod[c] != "Coastal"){
    hyp = paste0("Intercept + STRAT_mod",q75$STRAT_mod[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT_mod[c] == "Coastal"){
    hyp = paste0("Intercept + RAWMATERIAL",q75$RAWMATERIAL[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT_mod[c] != "Coastal"){
    hyp = paste0("Intercept + STRAT_mod", q75$STRAT_mod[c],
                 " + RAWMATERIAL", q75$RAWMATERIAL[c],
                   " + STRAT_mod", q75$STRAT_mod[c],
                 ":RAWMATERIAL", q75$RAWMATERIAL[c],
                 " < ",i)
  }
  
  h <- hypothesis(fit_mass_all_grouped, hyp)
  print(paste("Hypothesis for", hyp, "is", h$hypothesis$Post.Prob))
  
  c = c + 1
}

```

```{r tab-AllMassInd}
emmeans_res <- emmeans(fit_mass_all_ind, ~ STRAT*RAWMATERIAL,
                       type = "response")

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)


plot(emmeans_res)
supp_tab2 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 2. Posterior Estimate of the marginal means for the mass of all lithics conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab2, "../results/tables/Supp2.png")

```

```{r}
#| include: false

fit_df |>
  group_by(STRAT) |>
  summarize(q75 = quantile(log(MASS), 0.75)) |>
  slice(rep(1:n(), each = 3)) |>
  mutate(RAWMATERIAL = rep(c("Quartz", "Quartzite", "Silcrete"), 6)) -> q75

c = 1
for(i in q75$q75){
  
  if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT[c] == "1"){
    hyp = paste0("Intercept < ",i)
  }
  else if(q75$RAWMATERIAL[c] == "Quartz" & q75$STRAT[c] != "1"){
    hyp = paste0("Intercept + STRAT",q75$STRAT[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT[c] == "1"){
    hyp = paste0("Intercept + RAWMATERIAL",q75$RAWMATERIAL[c], " < ",i)
  }
  else if(q75$RAWMATERIAL[c] != "Quartz" & q75$STRAT[c] != "1"){
    hyp = paste0("Intercept + STRAT", q75$STRAT[c],
                 " + RAWMATERIAL", q75$RAWMATERIAL[c],
                   " + STRAT", q75$STRAT[c],
                 ":RAWMATERIAL", q75$RAWMATERIAL[c],
                 " < ",i)
  }
  
  h <- hypothesis(fit_mass_all_ind, hyp)
  print(paste("Hypothesis for", hyp, "is", h$hypothesis$Post.Prob))
  
  c = c + 1
}

# Remove models to expand storage space in R environment
rm(fit_mass_all_grouped)
rm(fit_mass_all_ind)
```

```{r AllMassGGplot}

df |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  mutate(STRAT_mod = as.factor(STRAT_mod),
         RAWMATERIAL = as.factor(RAWMATERIAL)) |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+

  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["QUant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Grouped Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot2



```

```{r fig-Figure7}

png("../results/figures/fig7.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Art_mass_freqPlot1,Art_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
fit_df <- df |>
    select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS, STRAT_mod) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL),
           log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(1, 0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(2,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(1,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")
```

```{r CoreMassBayesMods}
fit_mass_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257777
)

fit_mass_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257788
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_mass_core_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_core_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_mass_core_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_mass_core_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_core_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_mass_core_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_mass_core_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_mass_core_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_mass_core_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_mass_core_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_mass_core_ind, moment_match = T)
plot(loo1)
```

### Supp 3-4

```{r tab-CoreMassGroup}
#| warning: false
#| message: false
#| error: false


emmeans_res <- emmeans(fit_mass_core_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab3 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 3. Posterior Estimate of the marginal means for the mass of core tools conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab3, "../results/tables/Supp3.png")
```

```{r tab-CoreMassInd}
emmeans_res <- emmeans(fit_mass_core_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab4 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 4. Posterior Estimate of the marginal means for the mass of core tools conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab4, "../results/tables/Supp4.png")
```

```{r}
# Remove models to expand storage space in R environment
rm(fit_mass_core_grouped)
rm(fit_mass_core_ind)
```

```{r CoreMassGGplot}
#| warning: false
#| message: false
df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Grouped Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot2
```

```{r fig-Figure8}

png("../results/figures/fig8.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_mass_freqPlot1, Core_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreLength}
# Looking only at core Mass
fit_df <- df |>
    select(MASS, STRAT, STRAT_mod, RAWMATERIAL, MAXLENGTH, ARTIFACTCLASS) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL))


# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(18),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  
  prior(normal(3,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(18),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(0.5,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

```

```{r CoreLengthBayesMods}
fit_length_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557777
)

fit_length_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537788
)
```

```{r}
#| include: false


# Posterior checks for grouped data
pp_check(fit_length_core_grouped, type = "dens_overlay_grouped", 
         group = "STRAT_mod")
pp_check(fit_length_core_grouped, type = "stat_grouped", 
         group = "STRAT_mod")
pp_check(fit_length_core_grouped, type = "scatter_avg_grouped",
         group = "STRAT_mod")

pp_check(fit_length_core_grouped, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_grouped, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_grouped, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_length_core_grouped, moment_match = T)
plot(loo1)



# Posterior checks for individual data
pp_check(fit_length_core_ind, type = "dens_overlay_grouped", 
         group = "STRAT")
pp_check(fit_length_core_ind, type = "stat_grouped", 
         group = "STRAT")
pp_check(fit_length_core_ind, type = "scatter_avg_grouped",
         group = "STRAT")

pp_check(fit_length_core_ind, type = "dens_overlay_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_ind, type = "stat_grouped", 
         group = "RAWMATERIAL")
pp_check(fit_length_core_ind, type = "scatter_avg_grouped",
         group = "RAWMATERIAL")

loo1 <- loo(fit_length_core_ind, moment_match = T)
plot(loo1)
```

### Supp 5-6

```{r tab-CoreLengthGroup}
emmeans_res <- emmeans(fit_length_core_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

#plot(emmeans_res)

supp_tab5 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 5. Posterior Estimate of the marginal means for the maximum core length conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab5, "../results/tables/Supp5.png")
```

```{r tab-CoreLengthInd}
emmeans_res <- emmeans(fit_length_core_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab6 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 6. Posterior Estimate of the marginal means for the maximum core length conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab6, "../results/tables/Supp6.png")
```

```{r}
# Remove models to expand storage space in R environment
rm(fit_length_core_grouped)
rm(fit_length_core_ind)
```

```{r CoreLengthGGplot}
#| warning: false
#| message: false

df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, MAXLENGTH, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(MAXLENGTH, probs = 0.75),
         Median_mid50 = quantile(MAXLENGTH, probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  ggplot(aes(x = STRAT_mod, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
  xlab("Grouped Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "lightblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot2
```

```{r fig-Figure9}

png("../results/figures/fig9.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_length_freqPlot1, Core_length_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

## Toolkit composition

```{r fig-Figure10}

png("../results/figures/fig10.png", width = 180, height = 120,
    units = "mm", res = 300)
# Data pulled from Jerardino, 2022
sbf_df |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
  group_by(Layer) |>
  summarize(Tool_sum = sum(Count)) |>
  mutate(Lithic_Dens = c(602.7, 850.9,
                         ((819+1861)/((819/1863.6)+(1861/1094.7))),
                         2904.3, 1545.6, 2788.5),
         Dep_rate = abs(c(((2.45+2)/2)-((2.6+2.2)/2),
                      ((2.6+2.2)/2)-((3+2.4)/2),
                      ((3+2.4)/2)-((3.5+2.7)/2),
                      ((3.5+2.7)/2)-((5+3)/2),
                      ((5+3)/2)-(4.6),
                      ((9.7+4.6)/2)-(9.7)))) |>
  left_join(
    
    sbf_un |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
      group_by(Layer) |>
      summarize(Deb_sum = sum(Count)) 
    
) |>
  mutate(Tool_Perc = (Tool_sum/Deb_sum)*100,
         Lithic_std = Lithic_Dens/Dep_rate) |>
  
  ggplot(aes(x = Lithic_std, y = Tool_Perc, color = Layer, label = Layer))+
  geom_point(size = 3)+
  geom_text(aes(fontface = 2),hjust = 1.5, vjust = 0, size = 5)+
  xlab("Lithic Density/Deposition Rate")+ylab("Formal Tool Percent")+
  theme_minimal()+
  theme(text = element_text(size = 20))+
  guides(color = "none")+
  scale_color_manual(values = c("1" = "skyblue", "2" = "skyblue", "3" = "skyblue",
                                "4a" ="darkcyan", "4b" = "darkcyan",
                                "5" = "lightgreen"))

dev.off()
```

## Flake utility and reduction intensity

### Grouped layers (Small utility)

```{r}
lm_red <- df.flakes |>
  # filter by outliers and variables with < 10 observations
  filter(Utility_small < 3000,
         Utility_small > 0,
         FLAKETERMINATION != "Indeterminate",
         FLAKETERMINATION != "Axial",
         FLAKETERMINATION != "Splintered",
         
         FLAKEINITIATION != "",) |>
  select(
    # Maine variables
    Reduction, Utility_small,
    # covariates
    PLATFORMWIDTH, PLATFORMTHICKNESS, FLAKETERMINATION, FLAKEINITIATION,
    # Groups
    STRAT_mod) |>
  mutate(Plat_elong = PLATFORMWIDTH/PLATFORMTHICKNESS) |>
  select(Reduction, Utility_small, FLAKETERMINATION, FLAKEINITIATION, Plat_elong,
         STRAT_mod)


Bayes_ut1 <- lm_red |>
  mutate(Utility_s = Utility_small/100,
         
         Reduction_c = Reduction - mean(Reduction),
         Plat_elong_c = Plat_elong - mean(Plat_elong),
         
         Reduction_s = scale(Reduction, center = T, scale = T),
         Plat_elong_s = scale(Plat_elong, center = T, scale = T))

Bayes_ut1 <- Bayes_ut1[-c(619, 1334, 1478, 1533),]
Bayes_ut1 <- Bayes_ut1[-c(625, 1479),]


# Gamma prior
my_prior <-

  # Intercept
  prior(normal(0.5, 1), class = Intercept)+
  
  # Polynomial factor 1
  prior(normal(0.5, 1), class = b, coef = "polyReduction_s21")+

  # Polynomial factor 2
  prior(normal(0.5, 0.5), class = b, coef = "polyReduction_s22")+

  # Group-level SDs
  prior(exponential(1), class = sd)+

  # Gamma shape
  prior(exponential(1), class = shape)


  
  
# Run Bayesian model with varying slopes
bayes_ut1 <- brm(Utility_s ~ 1 + poly(Reduction_s, 2) +
                   (0 + poly(Reduction_s, 2) | STRAT_mod/RAWMATERIAL),
              data = Bayes_ut1,
              family = Gamma(link = "log"),
              iter = 6000,
              chains = 4,
              seed = 111,
              control = list(adapt_delta = 0.95),
              prior=my_prior,
              save_pars = save_pars(all = TRUE),
              cores = getOption("mc.cores", 14))
```

```{r}
#| include: false

# Validate model with posterior checks

pp_check(bayes_ut1, type = "dens_overlay")
pp_check(bayes_ut1, type = "stat")

pp_check(bayes_ut1, type = "scatter_avg_grouped", group = "STRAT_mod:RAWMATERIAL")



loo1 <- loo(bayes_ut1)

which(as.data.frame(loo1$pointwise)$influence_pareto_k > 0.7)
plot(loo1)
```

```{r}
x_seq <- seq(min(Bayes_ut1$Reduction_s, na.rm = TRUE),
             max(Bayes_ut1$Reduction_s, na.rm = TRUE),
             length.out = 100)

# All combinations of grouping levels
newdat <- expand_grid(
  Reduction_s = x_seq,
  STRAT_mod = unique(Bayes_ut1$STRAT_mod),
  RAWMATERIAL = unique(Bayes_ut1$RAWMATERIAL)
)

# Get fitted values (posterior draws of the mean)
preds <- fitted(
  bayes_ut1,       # your Gamma(log) model
  newdata = newdat,
  re_formula = NULL,    # include group-level effects
  summary = FALSE       # return full posterior draws
)

# Add to the grid and summarize
pred_summary <- newdat |>
  bind_cols(as_tibble(t(preds))) |>
  pivot_longer(cols = starts_with("V"), values_to = "Utility_pred") |>
  group_by(STRAT_mod, RAWMATERIAL, Reduction_s) |>
  summarise(
    mean = mean(Utility_pred),
    lower = quantile(Utility_pred, 0.025),
    upper = quantile(Utility_pred, 0.975),
    .groups = "drop"
  )


ggplot(pred_summary, aes(x = Reduction_s, y = mean, color = STRAT_mod)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = STRAT_mod), alpha = 0.2, color = NA) +
  facet_wrap(~ RAWMATERIAL, scales = "free_y") +
  labs(
    title = "Predicted Utility by Reduction level",
    subtitle = "Posterior mean and 95% credible interval per Raw Material and Strat Category",
    x = "Reduction (standardized)",
    y = "Predicted Utility"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")

```

```{r}
# Assign sequence to procude slope values
x_seq <- seq(min(Bayes_ut1$Reduction_s),
             max(Bayes_ut1$Reduction_s),
             length.out = 50)

# Group specific slopes
post <- spread_draws(
  bayes_ut1,
  b_Intercept,
  b_polyReduction_s21, b_polyReduction_s22,
  # Quartz
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`,
  
  # Quartzite
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`,
  
  # Silcrete
  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`,
  
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`,
  `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`
)

# Determine the optimal surplus based on where tangent = 0
posterior_x <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    # Quartz
    x_Quartz_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)),
    
    x_Quartz_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)),
    
    x_Quartz_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)),
    
    # QUartzite
    x_Quartzite_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`)),
    
    x_Quartzite_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`)),
    
    x_Quartzite_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`)),
    
    # Silcrete
    x_Silcrete_C = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`)),
    
    x_Silcrete_M = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`)),
    
    x_Silcrete_T = (b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`)),
    
    
    
        # Quartz
    y_Quartz_C = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)*
              x_Quartz_C),
    
    y_Quartz_M = ((b_polyReduction_s21 +
                      `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)*
              x_Quartz_M),
    
    y_Quartz_T = ((b_polyReduction_s21 +
                `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)*
              x_Quartz_T),
    
    # Quartzite
    y_Quartzite_C = (b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_C),
    
    y_Quartzite_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`)*
              x_Quartzite_M),
    
    y_Quartzite_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`)*
              x_Quartzite_T),
    
    # Silcrete
    y_Silcrete_C = ((b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`)*
              x_Silcrete_C),
    
    y_Silcrete_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`)*
              x_Silcrete_M),
    
    y_Silcrete_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`)*
              x_Silcrete_T)
  )
  
  
posterior_x |>
  select(starts_with("x")) |>
  pivot_longer(x_Quartz_C:x_Silcrete_T,
               names_to = "layer", values_to = "x_value") |>

  ggplot(aes(x = x_value, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.95,
               point_interval = mean_qi,
               linewidth = 0.5,
               size = 0.7) +
  scale_fill_manual(
    values = c("x_Quartz_T" = "forestgreen",
               "x_Quartz_M" = "darkmagenta",
               "x_Quartz_C" = "skyblue",
               
               "x_Quartzite_T" = "forestgreen",
               "x_Quartzite_M" = "darkmagenta",
               "x_Quartzite_C" = "skyblue",
               
               "x_Silcrete_T" = "forestgreen",
               "x_Silcrete_M" = "darkmagenta",
               "x_Silcrete_C" = "skyblue")) +
  
  
  labs(x = "Posterior Estimate for Reduction Intensity", y = "") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("x_Quartz_T" = "Quartz:Terrestrial",
               "x_Quartz_M" = "Quartz:Mixed",
               "x_Quartz_C" = "Quartz:Coastal",
               
               "x_Quartzite_T" = "Quartzite:Terrestrial",
               "x_Quartzite_M" = "Quartzite:Mixed",
               "x_Quartzite_C" = "Quartzite:Coastal",
               
               "x_Silcrete_T" = "Silcrete:Terrestrial",
               "x_Silcrete_M" = "Silcrete:Mixed",
               "x_Silcrete_C" = "Silcrete:Coastal")
  )


# SOme of these are negative because the spontaneous slopes are negative (see image below), confirming some curves contain mimimums, contradicting our initial model that suggests optimal surplus is maximized with large utility and large reduction intensity
posterior_x |>
  select(starts_with("y")) |>
  pivot_longer(y_Quartz_C:y_Silcrete_T,
               names_to = "layer", values_to = "x_value") |>

  ggplot(aes(x = x_value, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.95,
               point_interval = mean_qi,
               linewidth = 0.5,
               size = 0.7) +
  scale_fill_manual(
    values = c("y_Quartz_T" = "forestgreen",
               "y_Quartz_M" = "darkmagenta",
               "y_Quartz_C" = "skyblue",
               
               "y_Quartzite_T" = "forestgreen",
               "y_Quartzite_M" = "darkmagenta",
               "y_Quartzite_C" = "skyblue",
               
               "y_Silcrete_T" = "forestgreen",
               "y_Silcrete_M" = "darkmagenta",
               "y_Silcrete_C" = "skyblue")) +
  
  
  labs(x = "Posterior Estimate for Reduction Intensity", y = "") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("y_Quartz_T" = "Quartz:Terrestrial",
               "y_Quartz_M" = "Quartz:Mixed",
               "y_Quartz_C" = "Quartz:Coastal",
               
               "y_Quartzite_T" = "Quartzite:Terrestrial",
               "y_Quartzite_M" = "Quartzite:Mixed",
               "y_Quartzite_C" = "Quartzite:Coastal",
               
               "y_Silcrete_T" = "Silcrete:Terrestrial",
               "y_Silcrete_M" = "Silcrete:Mixed",
               "y_Silcrete_C" = "Silcrete:Coastal")
  ) +
  xlim(-25, 25)
```

```{r}
# Compute slope values
posterior_y <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    
    # Quartz
    slope_Quartz_C = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartz_M = ((b_polyReduction_s21 +
                      `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartz_T = ((b_polyReduction_s21 +
                `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    # Quartzite
    slope_Quartzite_C = ((b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartzite_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartzite_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    # Silcrete
    slope_Silcrete_C = ((b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Silcrete_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Silcrete_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`)*
              Reduction_s)
  )
```

```{r}

# Compute slope values
slope_draws <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    
    # Quartz
    slope_Quartz_C = ((b_polyReduction_s21 +
                         `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartz_M = ((b_polyReduction_s21 +
                      `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartz_T = ((b_polyReduction_s21 +
                `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartz,polyReduction_s22]`)*
              Reduction_s),
    
    # Quartzite
    slope_Quartzite_C = ((b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartzite_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Quartzite_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Quartzite,polyReduction_s22]`)*
              Reduction_s),
    
    # Silcrete
    slope_Silcrete_C = ((b_polyReduction_s21 +
                  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Silcrete_M = ((b_polyReduction_s21 +
                    `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    
    slope_Silcrete_T = ((b_polyReduction_s21 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
              `r_STRAT_mod:RAWMATERIAL[Terrestrial_Silcrete,polyReduction_s22]`)*
              Reduction_s)
  )

# Summarize and visualize slopes
slope_summary <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_C:slope_Silcrete_T, 
               names_to = "groups", values_to = "slopes") |>
  group_by(groups, Reduction_s) |>
  summarise(
    mean = mean(slopes),
    lower = quantile(slopes, 0.025),
    upper = quantile(slopes, 0.975),
    .groups = "drop"
  )


# Quartz slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Quartz_C",
                                             "slope_Quartz_M",
                                             "slope_Quartz_T")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups), 
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_discrete(labels = c("slope_Quartz_C" = "Coastal",
                       "slope_Quartz_M" = "Mixed",
                       "slope_Quartz_T" = "Terrestrial")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_quartz

# Quartzite slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Quartzite_C",
                                             "slope_Quartzite_M",
                                             "slope_Quartzite_T")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups), 
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_discrete(labels = c("slope_Quartzite_C" = "Coastal",
                       "slope_Quartzite_M" = "Mixed",
                       "slope_Quartzite_T" = "Terrestrial")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_quartzite

# Silcrete slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Silcrete_C",
                                             "slope_Silcrete_M",
                                             "slope_Silcrete_T")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups),
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_discrete(labels = c("slope_Silcrete_C" = "Coastal",
                       "slope_Silcrete_M" = "Mixed",
                       "slope_Silcrete_T" = "Terrestrial")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_silcrete

```

```{r}
ggarrange(
  slope_quartz, slope_quartzite, slope_silcrete,
  align = "h", labels = c("A", "B", "C"),
  nrow = 3, common.legend = TRUE,
  font.label = list(size = 15, face = "bold")
)
```

```{r}
# Test slope differences
compare_slope <- slope_draws |>
  mutate(diff1= slope_Quartz_C - slope_Quartz_M,
         diff2 = slope_Quartz_C - slope_Quartz_T,
         diff3 = slope_Quartz_M - slope_Quartz_T,
         
         diff4= slope_Quartzite_C - slope_Quartzite_M,
         diff5 = slope_Quartzite_C - slope_Quartzite_T,
         diff6 = slope_Quartzite_M - slope_Quartzite_T,
         
         diff7= slope_Silcrete_C - slope_Silcrete_M,
         diff8 = slope_Silcrete_C - slope_Silcrete_T,
         diff9 = slope_Silcrete_M - slope_Silcrete_T,
         
         
         quartz_CM = mean(diff1 > 0),
         quartz_CT = mean(diff2 > 0),
         quartz_MT = mean(diff3 > 0),
         
         quartzite_CM = mean(diff4 > 0),
         quartzite_CT = mean(diff5 > 0),
         quartzite_MT = mean(diff6 > 0),
         
         silcrete_CM = mean(diff7 > 0),
         silcrete_CT = mean(diff8 > 0),
         silcrete_MT = mean(diff9 > 0))

compare_slope |>
  select(quartz_CM:silcrete_MT) |>
  distinct() |>
  print()


pairwise_diffs <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_C:slope_Silcrete_T, names_to = "groups", values_to = "slopes") |>
  group_by(groups) |>
  summarise(mean_slope = mean(slopes),
            lower = quantile(slopes, 0.025),
            upper = quantile(slopes, 0.975))


```

```{r}
compare_slope |>
  select(starts_with("diff")) |>
  pivot_longer(diff1:diff9,
               names_to = "layer", values_to = "slope") |>
  
  ggplot(aes(x = slope, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.90,
               point_interval = mean_qi)
  scale_fill_manual(
    values = c("slope_Ter" = "forestgreen",
               "slope_Mix" = "darkmagenta",
               "slope_Aq" = "skyblue")) +
  
  
  labs(x = "Posterior Slope Estimate", y = "Phase") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 20),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("slope_Ter" = "Terrestrial",
               "slope_Mix" = "Mixed",
               "slope_Aq" = "Aquatic")
  )
```

### Individual layers (Small utility)

```{r}
# Gamma prior
my_prior <-

  # Intercept
  prior(normal(0.5, 1), class = Intercept)+
  
  # Polynomial factor 1
  prior(normal(0.5, 1), class = b, coef = "polyReduction_s21")+

  # Polynomial factor 2
  prior(normal(0.5, 0.5), class = b, coef = "polyReduction_s22")+

  # Group-level SDs
  prior(exponential(1), class = sd)+

  # Gamma shape
  prior(exponential(1), class = shape)


  
  
# Run Bayesian model with varying slopes
bayes_ut2 <- brm(Utility_s ~ 1 + poly(Reduction_s, 2) +
                   (0 + poly(Reduction_s, 2) | STRAT/RAWMATERIAL),
              data = Bayes_ut1,
              family = Gamma(link = "log"),
              iter = 4000,
              chains = 2,
              seed = 112,
              control = list(adapt_delta = 0.95),
              prior=my_prior,
              save_pars = save_pars(all = TRUE),
              cores = getOption("mc.cores", 14))
```

```{r}
#| include: false

# Validate model with posterior checks

pp_check(bayes_ut2, type = "dens_overlay")
pp_check(bayes_ut2, type = "stat")

pp_check(bayes_ut2, type = "scatter_avg_grouped", group = "STRAT:RAWMATERIAL")



loo1 <- loo(bayes_ut2)
#which(as.data.frame(loo1$pointwise)$influence_pareto_k > 0.7)
plot(loo1)
```

```{r}
x_seq <- seq(min(Bayes_ut1$Reduction_s, na.rm = TRUE),
             max(Bayes_ut1$Reduction_s, na.rm = TRUE),
             length.out = 100)

# All combinations of grouping levels
newdat <- expand_grid(
  Reduction_s = x_seq,
  STRAT = unique(Bayes_ut1$STRAT),
  RAWMATERIAL = unique(Bayes_ut1$RAWMATERIAL)
)

# Get fitted values (posterior draws of the mean)
preds <- fitted(
  bayes_ut2,       # your Gamma(log) model
  newdata = newdat,
  re_formula = NULL,    # include group-level effects
  summary = FALSE,       # return full posterior draws
  allow_new_levels = TRUE
)

# Add to the grid and summarize
pred_summary <- newdat |>
  bind_cols(as_tibble(t(preds))) |>
  pivot_longer(cols = starts_with("V"), values_to = "Utility_pred") |>
  group_by(STRAT, RAWMATERIAL, Reduction_s) |>
  summarise(
    mean = mean(Utility_pred),
    lower = quantile(Utility_pred, 0.025),
    upper = quantile(Utility_pred, 0.975),
    .groups = "drop"
  )


ggplot(pred_summary, aes(x = Reduction_s, y = mean, color = STRAT)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = STRAT), alpha = 0.2, color = NA) +
  facet_wrap(~ RAWMATERIAL, scales = "free_y") +
  labs(
    title = "Predicted Utility by Reduction level",
    subtitle = "Posterior mean and 95% credible interval per Raw Material and Strat Category",
    x = "Reduction (standardized)",
    y = "Predicted Utility"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")

```

```{r}
# Assign sequence to procude slope values
x_seq <- seq(min(Bayes_ut1$Reduction_s),
             max(Bayes_ut1$Reduction_s),
             length.out = 50)

# Group specific slopes
post <- spread_draws(
  bayes_ut2,
  b_Intercept,
  b_polyReduction_s21, b_polyReduction_s22,
  # Quartz
  `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s21]`,
  
  `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s22]`,

  
  # Quartzite
  `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s21]`,
  
  `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s22]`,
  
  
  # Silcrete
  `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s21]`,
  `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s21]`,
  
  `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s22]`,
  `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s22]`,
)

# Determine the optimal surplus based on where tangent = 0
posterior_x <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    # Quartz
    x_Quartz_1 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s22]`)),
    x_Quartz_2 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s22]`)),
    x_Quartz_3 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s22]`)),
    x_Quartz_4a = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s22]`)),
    x_Quartz_4b = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s22]`)),
    x_Quartz_5 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s22]`)),
    
    # QUartzite
    x_Quartzite_1 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s22]`)),
    x_Quartzite_2 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s22]`)),
    x_Quartzite_3 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s22]`)),
    x_Quartzite_4a = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s22]`)),
    x_Quartzite_4b = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s22]`)),
    x_Quartzite_5 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s22]`)),

    
    # Silcrete
    x_Silcrete_1 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s22]`)),
    x_Silcrete_2 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s22]`)),
    x_Silcrete_3 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s22]`)),
    x_Silcrete_4a = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s22]`)),
    x_Silcrete_4b = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s22]`)),
    x_Silcrete_5 = (b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s21]`)/
            -1*(2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s22]`)),
    
    
    
        # Quartz
    y_Quartz_1 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s22]`)*
              x_Quartz_1),
    y_Quartz_2 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s22]`)*
              x_Quartz_2),
    y_Quartz_3 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s22]`)*
              x_Quartz_3),
    y_Quartz_4a = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s22]`)*
              x_Quartz_4a),
    y_Quartz_4b = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s22]`)*
              x_Quartz_4b),
    y_Quartz_5 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s22]`)*
              x_Quartz_5),
    

    # Quartzite
    y_Quartzite_1 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_1),
    
    
    y_Quartzite_2 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_2),
    y_Quartzite_3 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_3),
    y_Quartzite_4a = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_4a),
    y_Quartzite_4b = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_4b),
    y_Quartzite_5 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s22]`)*
              2*(x_Quartzite_5),
    
    
    # Silcrete
    y_Silcrete_1 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s22]`)*
              x_Silcrete_1),
    y_Silcrete_2 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s22]`)*
              x_Silcrete_2),
    y_Silcrete_3 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s22]`)*
              x_Silcrete_3),
    y_Silcrete_4a = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s22]`)*
              x_Silcrete_4a),
    y_Silcrete_4b = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s22]`)*
              x_Silcrete_4b),
    y_Silcrete_5 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s22]`)*
              x_Silcrete_5)

  )
  
  
posterior_x |>
  select(starts_with("x")) |>
  pivot_longer(x_Quartz_1:x_Silcrete_5,
               names_to = "layer", values_to = "x_value") |>

  ggplot(aes(x = x_value, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.95,
               point_interval = mean_qi,
               linewidth = 0.5,
               size = 0.7) +
  scale_fill_manual(
    values = c("x_Quartz_5" = "forestgreen",
               "x_Quartz_4b" = "darkmagenta",
               "x_Quartz_4a" = "darkmagenta",
               "x_Quartz_3" = "skyblue",
               "x_Quartz_2" = "skyblue",
               "x_Quartz_1" = "skyblue",
               
               "x_Quartzite_5" = "forestgreen",
               "x_Quartzite_4b" = "darkmagenta",
               "x_Quartzite_4a" = "darkmagenta",
               "x_Quartzite_3" = "skyblue",
               "x_Quartzite_2" = "skyblue",
               "x_Quartzite_1" = "skyblue",
               
               "x_Silcrete_5" = "forestgreen",
               "x_Silcrete_4b" = "darkmagenta",
               "x_Silcrete_4a" = "darkmagenta",
               "x_Silcrete_3" = "skyblue",
               "x_Silcrete_2" = "skyblue",
               "x_Silcrete_1" = "skyblue")) +
  
  
  labs(x = "Posterior Estimate for Reduction Intensity", y = "") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("x_Quartz_5" = "Quartz:5",
               "x_Quartz_4b" = "Quartz:4b",
               "x_Quartz_4a" = "Quartz:4a",
               "x_Quartz_3" = "Quartz:3",
               "x_Quartz_2" = "Quartz:2",
               "x_Quartz_1" = "Quartz:1",
               
               "x_Quartzite_5" = "Quartzite:5",
               "x_Quartzite_4b" = "Quartzite:4b",
               "x_Quartzite_4a" = "Quartzite:4a",
               "x_Quartzite_3" = "Quartzite:3",
               "x_Quartzite_2" = "Quartzite:2",
               "x_Quartzite_1" = "Quartzite:1",
               
               "x_Silcrete_5" = "Silcrete:5",
               "x_Silcrete_4b" = "Silcrete:4b",
               "x_Silcrete_4a" = "Silcrete:4a",
               "x_Silcrete_3" = "Silcrete:3",
               "x_Silcrete_2" = "Silcrete:2",
               "x_Silcrete_1" = "Silcrete:1")
  ) + xlim(-10, 10)


# SOme of these are negative because the spontaneous slopes are negative (see image below), confirming some curves contain mimimums, contradicting our initial model that suggests optimal surplus is maximized with large utility and large reduction intensity
posterior_x |>
  select(starts_with("y")) |>
  pivot_longer(y_Quartz_1:y_Silcrete_5,
               names_to = "layer", values_to = "x_value") |>

  ggplot(aes(x = x_value, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.95,
               point_interval = mean_qi,
               linewidth = 0.5,
               size = 0.7) +
  scale_fill_manual(
    values = c("y_Quartz_5" = "forestgreen",
               "y_Quartz_4b" = "darkmagenta",
               "y_Quartz_4a" = "darkmagenta",
               "y_Quartz_3" = "skyblue",
               "y_Quartz_2" = "skyblue",
               "y_Quartz_1" = "skyblue",
               
               "y_Quartzite_5" = "forestgreen",
               "y_Quartzite_4b" = "darkmagenta",
               "y_Quartzite_4a" = "darkmagenta",
               "y_Quartzite_3" = "skyblue",
               "y_Quartzite_2" = "skyblue",
               "y_Quartzite_1" = "skyblue",
               
               "y_Silcrete_5" = "forestgreen",
               "y_Silcrete_4b" = "darkmagenta",
               "y_Silcrete_4a" = "darkmagenta",
               "y_Silcrete_3" = "skyblue",
               "y_Silcrete_2" = "skyblue",
               "y_Silcrete_1" = "skyblue")) +
  
  
  labs(x = "Posterior Estimate for Reduction Intensity", y = "") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("y_Quartz_5" = "Quartz:5",
               "y_Quartz_4b" = "Quartz:4b",
               "y_Quartz_4a" = "Quartz:4a",
               "y_Quartz_3" = "Quartz:3",
               "y_Quartz_2" = "Quartz:2",
               "y_Quartz_1" = "Quartz:1",
               
               "y_Quartzite_5" = "Quartzite:5",
               "y_Quartzite_4b" = "Quartzite:4b",
               "y_Quartzite_4a" = "Quartzite:4a",
               "y_Quartzite_3" = "Quartzite:3",
               "y_Quartzite_2" = "Quartzite:2",
               "y_Quartzite_1" = "Quartzite:1",
               
               "y_Silcrete_5" = "Silcrete:5",
               "y_Silcrete_4b" = "Silcrete:4b",
               "y_Silcrete_4a" = "Silcrete:4a",
               "y_Silcrete_3" = "Silcrete:3",
               "y_Silcrete_2" = "Silcrete:2",
               "y_Silcrete_1" = "Silcrete:1")
  ) +
  xlim(-25, 25)
```

```{r}
# Compute slope values
slope_draws <- post |>
  mutate(draw = row_number()) |>
  tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    
        # Quartz
    slope_Quartz_1 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartz,polyReduction_s22]`)*
              Reduction_s),
    slope_Quartz_2 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartz,polyReduction_s22]`)*
              Reduction_s),
    slope_Quartz_3 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartz,polyReduction_s22]`)*
              Reduction_s),
    slope_Quartz_4a = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartz,polyReduction_s22]`)*
              Reduction_s),
    slope_Quartz_4b = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartz,polyReduction_s22]`)*
              Reduction_s),
    slope_Quartz_5 = ((b_polyReduction_s21 +
                         `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartz,polyReduction_s22]`)*
              Reduction_s),
    

    # Quartzite
    slope_Quartzite_1 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    
    
    slope_Quartzite_2 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    slope_Quartzite_3 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    slope_Quartzite_4a = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    slope_Quartzite_4b = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    slope_Quartzite_5 = (b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s21]`) +
            (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Quartzite,polyReduction_s22]`)*
              2*(Reduction_s),
    
    
    # Silcrete
    slope_Silcrete_1 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[1_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    slope_Silcrete_2 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[2_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    slope_Silcrete_3 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[3_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    slope_Silcrete_4a = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4a_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    slope_Silcrete_4b = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[4b_Silcrete,polyReduction_s22]`)*
              Reduction_s),
    slope_Silcrete_5 = ((b_polyReduction_s21 +
                  `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s21]`) +
            2 * (b_polyReduction_s22 +
                   `r_STRAT:RAWMATERIAL[5_Silcrete,polyReduction_s22]`)*
              Reduction_s)
    
  )

# Summarize and visualize slopes
slope_summary <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_1:slope_Silcrete_5, 
               names_to = "groups", values_to = "slopes") |>
  group_by(groups, Reduction_s) |>
  summarise(
    mean = mean(slopes),
    lower = quantile(slopes, 0.025),
    upper = quantile(slopes, 0.975),
    .groups = "drop"
  )


# Quartz slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Quartz_5",
                                             "slope_Quartz_4b",
                                             "slope_Quartz_4a",
                                             "slope_Quartz_3",
                                             "slope_Quartz_2",
                                             "slope_Quartz_1")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups), 
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed")+
  scale_fill_discrete(labels = c("slope_Quartz_5" = "5",
                                 "slope_Quartz_4b" = "4b",
                                 "slope_Quartz_4a" = "4a",
                                 "slope_Quartz_3" = "3",
                                 "slope_Quartz_2" = "2",
                                 "slope_Quartz_1" = "1")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_quartz

# Quartzite slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Quartzite_5",
                                             "slope_Quartzite_4b",
                                             "slope_Quartzite_4a",
                                             "slope_Quartzite_3",
                                             "slope_Quartzite_2",
                                             "slope_Quartzite_1")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups), 
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_fill_discrete(labels = c("slope_Quartzite_5" = "5",
                                 "slope_Quartzite_4b" = "4b",
                                 "slope_Quartzite_4a" = "4a",
                                 "slope_Quartzite_3" = "3",
                                 "slope_Quartzite_2" = "2",
                                 "slope_Quartzite_1" = "1")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_quartzite

# Silcrete slope diagram
ggplot(slope_summary |> filter(groups %in% c("slope_Silcrete_5",
                                             "slope_Silcrete_4b",
                                             "slope_Silcrete_4a",
                                             "slope_Silcrete_3",
                                             "slope_Silcrete_2",
                                             "slope_Silcrete_1")),
       aes(x = Reduction_s, y = mean, color = groups)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = groups),
              alpha = 0.2, color = NA) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_color_discrete(labels = c("slope_Silcrete_5" = "5",
                                 "slope_Silcrete_4b" = "4b",
                                 "slope_Silcrete_4a" = "4a",
                                 "slope_Silcrete_3" = "3",
                                 "slope_Silcrete_2" = "2",
                                 "slope_Silcrete_1" = "1")) +
  labs(y = "Slope",
       x = "Reduction (Scaled)") +
  theme(text = element_text(size = 15)) +
  theme_bw() -> slope_silcrete

```

```{r}
ggarrange(
  slope_quartz, slope_quartzite, slope_silcrete,
  align = "h", labels = c("A", "B", "C"),
  nrow = 3, common.legend = TRUE,
  font.label = list(size = 15, face = "bold")
)
```

```{r}
# Test slope differences
compare_slope <- slope_draws |>
  mutate(# Quartz comparisons
         diff1= slope_Quartz_1 - slope_Quartz_2,
         diff2= slope_Quartz_1 - slope_Quartz_3,
         diff3= slope_Quartz_1 - slope_Quartz_4a,
         diff4= slope_Quartz_1 - slope_Quartz_4b,
         diff5= slope_Quartz_1 - slope_Quartz_5,
         
         diff6= slope_Quartz_2 - slope_Quartz_3,
         diff7= slope_Quartz_2 - slope_Quartz_4a,
         diff8= slope_Quartz_2 - slope_Quartz_4b,
         diff9= slope_Quartz_2 - slope_Quartz_5,
         
         diff10= slope_Quartz_3 - slope_Quartz_4a,
         diff11= slope_Quartz_3 - slope_Quartz_4b,
         diff12= slope_Quartz_3 - slope_Quartz_5,
         
         diff13= slope_Quartz_4a - slope_Quartz_4b,
         diff14= slope_Quartz_4a - slope_Quartz_5,
         
         diff15= slope_Quartz_4b - slope_Quartz_5,
         
         
         # QUartzite comparisons
         diff16= slope_Quartzite_1 - slope_Quartzite_2,
         diff17= slope_Quartzite_1 - slope_Quartzite_3,
         diff18= slope_Quartzite_1 - slope_Quartzite_4a,
         diff19= slope_Quartzite_1 - slope_Quartzite_4b,
         diff20= slope_Quartzite_1 - slope_Quartzite_5,
         
         diff21= slope_Quartzite_2 - slope_Quartzite_3,
         diff22= slope_Quartzite_2 - slope_Quartzite_4a,
         diff23= slope_Quartzite_2 - slope_Quartzite_4b,
         diff24= slope_Quartzite_2 - slope_Quartzite_5,
         
         diff25= slope_Quartzite_3 - slope_Quartzite_4a,
         diff26= slope_Quartzite_3 - slope_Quartzite_4b,
         diff27= slope_Quartzite_3 - slope_Quartzite_5,
         
         diff28= slope_Quartzite_4a - slope_Quartzite_4b,
         diff29= slope_Quartzite_4a - slope_Quartzite_5,
         
         diff30= slope_Quartzite_4b - slope_Quartzite_5,
         
         
         # Silcrete comparisons
         diff31= slope_Silcrete_1 - slope_Silcrete_2,
         diff32= slope_Silcrete_1 - slope_Silcrete_3,
         diff33= slope_Silcrete_1 - slope_Silcrete_4a,
         diff34= slope_Silcrete_1 - slope_Silcrete_4b,
         diff35= slope_Silcrete_1 - slope_Silcrete_5,
         
         diff36= slope_Silcrete_2 - slope_Silcrete_3,
         diff37= slope_Silcrete_2 - slope_Silcrete_4a,
         diff38= slope_Silcrete_2 - slope_Silcrete_4b,
         diff39= slope_Silcrete_2 - slope_Silcrete_5,
         
         diff40= slope_Silcrete_3 - slope_Silcrete_4a,
         diff41= slope_Silcrete_3 - slope_Silcrete_4b,
         diff42= slope_Silcrete_3 - slope_Silcrete_5,
         
         diff43= slope_Silcrete_4a - slope_Silcrete_4b,
         diff44= slope_Silcrete_4a - slope_Silcrete_5,
         
         diff45= slope_Silcrete_4b - slope_Silcrete_5
         )


compare_slope |> select(starts_with("diff")) |>
  summarize(across(c(diff1:diff45), ~ mean(.x > 0)))


pairwise_diffs <- slope_draws |>
  select(c(starts_with("slope"), Reduction_s)) |>
  pivot_longer(slope_Quartz_1:slope_Silcrete_5, names_to = "groups", values_to = "slopes") |>
  group_by(groups) |>
  summarise(mean_slope = mean(slopes),
            lower = quantile(slopes, 0.025),
            upper = quantile(slopes, 0.975)) |>
  print()
```

```{r}
#| include: false

# Plot: too large for this number of slope comparisons
compare_slope |>
  select(starts_with("diff")) |>
  pivot_longer(diff1:diff45,
               names_to = "layer", values_to = "slope") |>
  
  ggplot(aes(x = slope, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.90,
               point_interval = mean_qi) +
  scale_fill_manual(
    values = c("slope_Ter" = "forestgreen",
               "slope_Mix" = "darkmagenta",
               "slope_Aq" = "skyblue")) +
  
  
  labs(x = "Posterior Slope Estimate", y = "Phase") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 20),
        legend.position = "none")+
  guides(color = "none") +
  scale_y_discrete(
    labels = c("slope_Ter" = "Terrestrial",
               "slope_Mix" = "Mixed",
               "slope_Aq" = "Aquatic")
  )
```

### Adapted Surovell's approach

```{r fig-Figure11}
png("../results/figures/fig11.png", width = 180, height = 120,
    units = "mm", res = 300)

df.flakes |>
  select(STRAT, STRAT_mod, RAWMATERIAL, Utility_small, Reduction) |>
  group_by(STRAT, RAWMATERIAL) |>
  na.omit()|>
  summarize(Utility_ave = mean(Utility_small),
            Red_ave = mean(Reduction),
            
            Utility_sd = sd(Utility_small),
            Red_sd = sd(Reduction)) |>
  
  ggplot(aes(x = Red_ave, y = Utility_ave, 
                   color = STRAT, label = STRAT))+
    geom_point(size = 2)+
    geom_ellipse(aes(x0 = Red_ave, y0 = Utility_ave,
                     a = Red_sd, b = Utility_sd,
                     angle = 0))+
    facet_wrap(~RAWMATERIAL)+
    geom_text(aes(fontface = 2),hjust = 1.1, vjust = -0.2)+
  
  
    xlab("Reduction Intensity")+ylab("Flake Utility")+
    theme_light()+
    theme(legend.title = element_blank(), text = element_text(size = 15))+
    guides(color = "none")+
    scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                   "3" = "skyblue",
                                   "4a" = "darkcyan", "4b" = "darkcyan",
                                   "5" = "lightgreen"))

dev.off()
```

## Retouched flake utility to retouch intensity

```{r FlakeRetouch}
# Define retouch metrics
df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "MinimallyRetouched") |>
  mutate(Ratio =
           ((EDGETHICKNESS_1+EDGETHICKNESS_2+EDGETHICKNESS_3)/3)/MAXTHICKNESS,
         Region = RETOUCHREGIONNUMBER/8,
         Ratio = rescale(Ratio, to = c(0, 10)),
         Region = rescale(Region, to = c(0, 10)),
         
         ) -> ret_int
```

### Grouped layers

```{r}

# Refine outliers and define priors and run bayesian model
lm_red <- ret_int |>
  filter(Utility_small < 3000,
         Utility_small > 0) |>
  mutate(Retouch_Intensity = (Ratio+Region)/2)


Bayes_red1 <- lm_red |>
  mutate(Utility_s = Utility_small/100,
         
         Retouch_Intensity_s = scale(Retouch_Intensity, center = T, scale = T))


# Gamma prior
my_prior <-

  # Intercept
  prior(normal(0.5, 1), class = Intercept)+
  
  # Fixed effect
  prior(normal(0.5, 1), class = b, coef = "polyRetouch_Intensity_s21")+
  
  # Fixed effect
  prior(normal(0.5, 1), class = b, coef = "polyRetouch_Intensity_s22")+

  # Group-level SDs
  prior(exponential(1), class = sd)+

  # Gamma shape
  prior(exponential(1), class = shape)


  
  
# Run Bayesian model with varying slopes
bayes_re1 <- brm(Utility_s ~ 1 + poly(Retouch_Intensity_s, 2) +
                   (0 + poly(Retouch_Intensity_s, 2) | STRAT_mod/RAWMATERIAL),
              data = Bayes_red1,
              family = Gamma(link = "log"),
              iter = 6000,
              chains = 4,
              seed = 117222,
              control = list(adapt_delta = 0.95),
              prior=my_prior,
              save_pars = save_pars(all = TRUE),
              cores = getOption("mc.cores", 14))

my_prior <-

  # Intercept
  prior(normal(0.5, 1), class = Intercept)+
  
  # Fixed effect
  prior(normal(0.5, 1), class = b, coef = "Retouch_Intensity_s")+

  # Group-level SDs
  prior(exponential(1), class = sd)+

  # Gamma shape
  prior(exponential(1), class = shape)

bayes_re1_simp <- brm(Utility_s ~ 1 + Retouch_Intensity_s +
                   (0 + Retouch_Intensity_s | STRAT_mod/RAWMATERIAL),
              data = Bayes_red1,
              family = Gamma(link = "log"),
              iter = 6000,
              chains = 4,
              seed = 1172223,
              control = list(adapt_delta = 0.95),
              prior=my_prior,
              save_pars = save_pars(all = TRUE),
              cores = getOption("mc.cores", 14))
```

```{r}
# Check posterior distirbutions and compare models
# simpler model (linear) fits best
loo_re1 <- loo(bayes_re1)
loo_simp <- loo(bayes_re1_simp)

loo_compare(loo_re1, loo_simp)


pp_check(bayes_re1_simp, type = "scatter_avg_grouped", group = "STRAT_mod:RAWMATERIAL")
pp_check(bayes_re1, type = "scatter_avg_grouped", group = "STRAT_mod:RAWMATERIAL")

pp_check(bayes_re1_simp)
pp_check(bayes_re1)


# Assign model to simpler
bayes_re1 <- bayes_re1_simp
```

```{r}
x_seq <- seq(min(Bayes_red1$Retouch_Intensity_s, na.rm = TRUE),
             max(Bayes_red1$Retouch_Intensity_s, na.rm = TRUE),
             length.out = 100)

# All combinations of grouping levels
newdat <- expand_grid(
  Retouch_Intensity_s = x_seq,
  STRAT_mod = unique(Bayes_red1$STRAT_mod),
  RAWMATERIAL = unique(Bayes_red1$RAWMATERIAL)
)

# Get fitted values (posterior draws of the mean)
preds <- fitted(
  bayes_re1,       # your Gamma(log) model
  newdata = newdat,
  re_formula = NULL,    # include group-level effects
  summary = FALSE,       # return full posterior draws
  allow_new_levels = TRUE
)

# Add to the grid and summarize
pred_summary <- newdat |>
  bind_cols(as_tibble(t(preds))) |>
  pivot_longer(cols = starts_with("V"), values_to = "Utility_pred") |>
  group_by(STRAT_mod, RAWMATERIAL, Retouch_Intensity_s) |>
  summarise(
    mean = mean(Utility_pred),
    lower = quantile(Utility_pred, 0.025),
    upper = quantile(Utility_pred, 0.975),
    .groups = "drop"
  )


ggplot(pred_summary, aes(x = Retouch_Intensity_s, y = mean, color = STRAT_mod)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower, ymax = upper, fill = STRAT_mod), alpha = 0.2, color = NA) +
  facet_wrap(~ RAWMATERIAL, scales = "free_y") +
  labs(
    title = "Predicted Utility by Retouch Intensity",
    subtitle = "Posterior mean and 95% credible interval per Raw Material and Strat Category",
    x = "Reduction (standardized)",
    y = "Predicted Utility"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")
```

```{r}


# Group specific slopes
post <- spread_draws(
  bayes_re1,
  b_Intercept,
  b_Retouch_Intensity_s,
  
  # Coastal
  `r_STRAT_mod[Coastal,Retouch_Intensity_s]`,
  # Mixed
  `r_STRAT_mod[Mixed,Retouch_Intensity_s]`,
  
  # Quartz
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,Retouch_Intensity_s]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,Retouch_Intensity_s]`,
  
  # Quartzite
  `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,Retouch_Intensity_s]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,Retouch_Intensity_s]`,
  
  # Silcrete
  `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,Retouch_Intensity_s]`,
  
  `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,Retouch_Intensity_s]`
)

```

```{r}
# Compute slope values
slope_draws <- post |>
  mutate(draw = row_number()) |>
  #tidyr::crossing(Reduction_s = x_seq) |>
  mutate(
    
    # Quartz
    slope_Quartz_C = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Coastal,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Coastal_Quartz,Retouch_Intensity_s]`,
    
    slope_Quartz_M = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Mixed,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Mixed_Quartz,Retouch_Intensity_s]`,
    
    # Quartzite
    slope_Quartzite_C = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Coastal,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Coastal_Quartzite,Retouch_Intensity_s]`,
    
    slope_Quartzite_M = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Mixed,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Mixed_Quartzite,Retouch_Intensity_s]`,
    
    
    # Silcrete
    slope_Silcrete_C = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Coastal,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Coastal_Silcrete,Retouch_Intensity_s]`,
    
    slope_Silcrete_M = b_Retouch_Intensity_s + 
      `r_STRAT_mod[Mixed,Retouch_Intensity_s]` +
      `r_STRAT_mod:RAWMATERIAL[Mixed_Silcrete,Retouch_Intensity_s]`
  )

# Summarize and visualize slopes
slope_summary <- slope_draws |>
  select(c(starts_with("slope"))) |>
  pivot_longer(slope_Quartz_C:slope_Silcrete_M, 
               names_to = "groups", values_to = "slopes") |>
  group_by(groups) |>
  summarise(
    mean = mean(slopes),
    lower = quantile(slopes, 0.025),
    upper = quantile(slopes, 0.975),
    .groups = "drop"
  )


ggplot(slope_summary,
       aes(x = groups, y = mean,
           ymin = lower, ymax = upper)) +
  geom_pointrange(position = position_dodge(width = 0.4)) +
  coord_flip() +
  labs(y = "Posterior slope") +
  theme_minimal()
```

```{r}
# Probability that the difference in slopes is greater than 0
compare_slope <- slope_draws |>
  mutate(diff1= slope_Quartz_C - slope_Quartz_M,
         
         diff2= slope_Quartzite_C - slope_Quartzite_M,
         
         diff3= slope_Silcrete_C - slope_Silcrete_M)

compare_slope |>
  summarize(across(diff1:diff3, ~ mean(.x > 0))) |>
  print()


pairwise_diffs <- slope_draws |>
  select(c(starts_with("slope"))) |>
  pivot_longer(slope_Quartz_C:slope_Silcrete_M, names_to = "groups", values_to = "slopes") |>
  group_by(groups) |>
  summarise(mean_slope = mean(slopes),
            lower = quantile(slopes, 0.025),
            upper = quantile(slopes, 0.975)) |>
  print()

# Probability that the slopes are less than 0
slope_draws |>
  summarize(across(slope_Quartz_C:slope_Silcrete_M, ~ mean(.x < 0)))
```

```{r}
compare_slope |>
  select(starts_with("diff")) |>
  rename("Quartz" = "diff1",
         "Quartzite" = "diff2",
         "Silcrete" = "diff3") |>
  pivot_longer(`Quartz`:`Silcrete`,
               names_to = "layer", values_to = "slope") |>
  
  ggplot(aes(x = slope, y = layer, fill = layer)) +
  stat_halfeye(.width = 0.90,
               point_interval = mean_qi)+
  
  
  labs(x = "Posterior Slope Estimate (Coastal - Mixed)", y = "Raw material") +
  
  theme_minimal()+
  theme(legend.title = element_blank(),
        text = element_text(size = 20),
        legend.position = "none")+
  guides(color = "none")
```

### Individual layers

### Adapted Surovell's approach

```{r fig-Figure12}

png("../results/figures/fig12.png", width = 180, height = 120,
    units = "mm", res = 300)

ret_int |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  summarize(Utility_ave = mean(Utility_small, na.rm = T),
            Utility_sd = sd(Utility_small, na.rm = T),
            
            Ret_ave = mean((Ratio+Region), na.rm = T),
            Ret_sd = sd((Ratio+Region), na.rm = T)) |>
  
  ggplot(aes(x = Ret_ave, y = Utility_ave, 
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  geom_ellipse(aes(x0 = Ret_ave, y0 = Utility_ave,
                   a = Ret_sd, b = Utility_sd,
                   angle = 0))+
  facet_wrap(~RAWMATERIAL)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Flake Retouch Intensity")+ylab("Flake Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Cores

```{r coreVolumeRemoved}
df.flakes |>
  select(RAWMATERIAL, STRAT, PLATFORMTHICKNESS, MAXTHICKNESS) |>
  group_by(RAWMATERIAL, STRAT) |>
  na.omit() |>
  summarize(m_plat = mean(PLATFORMTHICKNESS),
            m_thick = mean(MAXTHICKNESS)) |>
  arrange(STRAT, RAWMATERIAL) -> flake.vr

flake.vr |>
  left_join(df.cores) |>
  select(m_plat, m_thick,
         STRAT, RAWMATERIAL, MAXLENGTH, MAXWIDTH, MAXTHICKNESS,
         FLAKEGENERATIONSTHICKNESS, FLAKEGENERATIONSLENGTH, FLAKEGENERATIONSWIDTH,
         SA_Ellipse, SCARCOUNT) |>
  na.omit() |>
  group_by(RAWMATERIAL, STRAT) |>
  mutate(V = pi*(4/3)*(MAXLENGTH/2)*(MAXWIDTH/2)*(MAXTHICKNESS/2),
         VR = pi*(4/3)*((MAXLENGTH + (m_plat*FLAKEGENERATIONSLENGTH))/2)*
                       ((MAXWIDTH + (m_plat*FLAKEGENERATIONSWIDTH))/2)*
                       ((MAXTHICKNESS + (m_thick*FLAKEGENERATIONSTHICKNESS))/2),
         volume_removed = (V/VR)*100,
         
         SDI = SCARCOUNT/SA_Ellipse) |>
  select(STRAT, RAWMATERIAL, V, VR, volume_removed, SDI, SA_Ellipse)-> cores.vr
```

```{r fig-Figure13}
# Tells us:
# High reduction intensity and low utility is more mobile
# High reduction and high utility is sedentary but low reduction and high utility is fully sedentary?
# Low reduction intensity and low utility means not focused on flake production?

png("../results/figures/fig13.png", width = 180, height = 120,
    units = "mm", res = 300)

cores.vr |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(volume_ave = mean(V),
            sdi_ave = mean(SDI),
            volumeRec_mean = mean(volume_removed)) |>
  ggplot(aes(x = volumeRec_mean, y = log(volume_ave),
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  facet_grid(~RAWMATERIAL)+
  
  
  xlab("Core Reduction Intensity")+ylab("log-Core Utility")+
  theme_light()+
  theme(legend.title = element_blank(), 
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Scraper utility and retouch intensity

```{r scraperRetouchIntensity}
# Define a database for scraper retouch
df.scrap <- df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "SideScraper" | 
           RETOUCHEDPIECETYPOLOGY == "EndScraper" |
           RETOUCHEDPIECETYPOLOGY == "Side-EndScraper") |>
  select("SCRAPERRETOUCHHEIGHT1", "SCRAPERRETOUCHHEIGHT2", "SCRAPERRETOUCHHEIGHT3",
         "SCRAPERRETOUCHANGLE1", "SCRAPERRETOUCHANGLE2", "SCRAPERRETOUCHANGLE3",
         "SCRAPERDORSALANGLE1", "SCRAPERDORSALANGLE2", "SCRAPERDORSALANGLE3",
         "SCRAPERRETOUCHLENGTH",
         "SCRAPERMAXTHICKNESS",
         "MAXLENGTH", "MAXWIDTH",
         
         "RAWMATERIAL", "STRAT", "MASS") |>
  na.omit() |>
  mutate(RET_INT = round(((SCRAPERRETOUCHHEIGHT1+
                            SCRAPERRETOUCHHEIGHT2+
                            SCRAPERRETOUCHHEIGHT3)/SCRAPERMAXTHICKNESS)*
                           SCRAPERRETOUCHLENGTH,2),
         SA = MAXLENGTH*MAXWIDTH)


# Preprocess data to enter into custom function to calculate scraper reduction
scrap.red <- df.scrap |>
  na.omit() |>
  mutate(D = (SCRAPERRETOUCHHEIGHT1+SCRAPERRETOUCHHEIGHT2+SCRAPERRETOUCHHEIGHT3)/3,
         a = (SCRAPERRETOUCHANGLE1+SCRAPERRETOUCHANGLE2+SCRAPERRETOUCHANGLE3)/3,
         b = (SCRAPERDORSALANGLE1+SCRAPERDORSALANGLE2+SCRAPERDORSALANGLE3)/3) |>
  rename(L = SCRAPERRETOUCHLENGTH)

scrap.red <- scraper_red(scrap.red$L, scrap.red$D, scrap.red$a, scrap.red$b)/1000

scrap.red <- scrap.red |>
  mutate(RETOUCH = as.vector(scrap.red$Reduction),
         STRAT = df.scrap$STRAT,
         UTILITY = df.scrap$MAXWIDTH*df.scrap$MAXLENGTH,
         
         RAWMATERIAL = df.scrap$RAWMATERIAL,
         
         RE_Ut = UTILITY/Reduction,
         
         MASS = df.scrap$MASS)
```

```{r fig-Figure14}

png("../results/figures/fig14.png", width = 180, height = 120,
    units = "mm", res = 300)

scrap.red |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Silcrete")) |>
  summarize(Retouch_ave = mean(RETOUCH),
            Utility_ave = mean(UTILITY))|>
  ggplot(aes(x = Retouch_ave, y = Utility_ave, 
             color = STRAT, label = STRAT))+
  geom_point(size = 3)+
  facet_grid(~RAWMATERIAL)+
  geom_text(aes(fontface = 2.5),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Scraper Retouch Intensity")+ylab("Scraper Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 17))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Additional analysis on Adzes

```{r}
#| include: false

df_adze <- df |>
  as_tibble() |>
  filter(RETOUCHEDPIECETYPOLOGY == "Adze") |>
  select(STRAT, RAWMATERIAL, SCARCOUNT,
         MAXLENGTH, MAXWIDTH, MAXTHICKNESS, MASS) |>
  mutate(SA = 2*((MAXLENGTH*MAXWIDTH)+
                   (MAXTHICKNESS*MAXWIDTH)+
                   (MAXTHICKNESS*MAXLENGTH)),
         SDI = SA/SCARCOUNT)

df_adze |>
  ggplot(aes(x = STRAT, y = SDI))+
  geom_boxplot()

df_adze |>
  ggplot(aes(x = STRAT, y = log(MASS)))+
  geom_boxplot()

TukeyHSD(aov(lm(SDI~STRAT, data = df_adze)))
```
