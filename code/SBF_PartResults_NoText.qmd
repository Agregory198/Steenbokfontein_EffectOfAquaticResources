---
title: "Steenbokfontein Preliminary Results"
execute: 
  echo: false
  warning: false
  message: false
format: docx
editor: visual
---

```{r library}
#| warning: false
#| message: false


# To plot figures
library(ggplot2)
library(forcats)
library(ggpubr)
library(ggridges)
library(cowplot)

library(infer)

library(viridis)

library(scales)
library(stringr)

# To generate tables
library(gtsummary)
library(gt)
library(broom)
library(broom.mixed)

library(stargazer)
library(kableExtra)

# To tidy the data
library(tidyr)
library(tidyverse)
library(dplyr)
library(forcats)
library(tidybayes)

# Bayesian models
library(brms)
library(emmeans)
```

```{r ScraperRetouchFormula}
# Calculate scraper retouch intensity
scraper_red <- function(L, D, a, b){
  
  t = D * sin(a)
  D3 = D * cos(a)
  D1 = t/(sin(b))
  D4 = (t * cos(b))/(sin(b))
  
  D2 = D4 - D3
  
  B = t * (sin(b)) # define base B to find height (which is also D1)
  
  h = sin(b) * ((t*(cos(b)/sin(b))) - (D*cos(a)))
  
  A =  0.5 * B * h# find values of area now
  
  RE = L*((D^2)/2)*((sin(a*(pi/180))^2 * 
                       (cos(b*(pi/180))/sin(b*(pi/180)))) - 
                      (sin(a*(pi/180)) * cos(a*(pi/180))))
  
  
  output <- tibble(Reduction = RE)
  
  return(output)
  
  
}
```

```{r ReadData}
#| message: false
#| warning: false

# Read and clean data
df_sum24 <- read.csv("../data/AG_Summer2024_SBF_Final.csv") |>
  select(-c('X')) |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"), "Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))

df_sum25 <- read.csv("../data/AG_Summer2025_SBF_Final.csv") |>
  filter(RAWMATERIAL != "BWA UPPER 1" &
           RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                        ifelse(STRAT == "3b", "3", STRAT)),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  select(-c(X))

# student's dataframe
df_One <- read_csv("../data/DataSheet_1.csv")|>
  mutate(STRAT = tolower(Layer),
         
         PLATFORMWIDTH = parse_number("Platform Width"),
         PLATFORMTHICKNESS = parse_number("Platform Thickness"),
         MAXLENGTH = parse_number("Maximum Length"),
         TECHLENGTH = parse_number("Technological Length"),
         MAXWIDTH = parse_number("Maximum Width"),
         TECHWIDTH = parse_number("Technological Width"),
         MAXTHICKNESS = parse_number("Thickness"),
         MASS = parse_number("Mass"))

df_One <- df_One[1:289,]

df_One_flakes <- df_One |>
  
  add_column(OTHERUNIT = NA, .before = "Raw Material") |>

  rename(SITE = Site, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         CORTEXTYPE = `Cortex Origin`, ARTIFACTCLASS = `Artifact class`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = PlatformAbrasion, 
         STAGE = `Flaking Stage`) |>
  
  select(-c(Layer, Notes, Photo,
            `Platform Width`:`Platform Thickness`, `Maximum Length`:Mass)) |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                      ifelse(STRAT == "3b", "3", 
                             ifelse(STRAT == "5a", "5", STRAT))),
         STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod)) |>
  
  relocate(STRAT, .before = "UNIT") |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  
  

# student's Dataframe
df_Two <- read_csv("../data/DataSheet_2.csv") |>
  
  rename(SITE = Site, STRAT = Layer, UNIT = Unit, NAMED_ID = `Other Name`,
         RAWMATERIAL = `Raw Material`, CORTEX = `Cortex Percent`,
         ARTIFACTCLASS = `Artifact class`, CORTEXTYPE = `Cortex Origin`,
         COMPLETENESS = Complete, PLATFORM = `Platform?`,
         FLAKEINITIATION = Initiated, FLAKETERMINATION = Termination,
         FLAKEGEOMETRY = `Flake Geometry`, PLATFORMPREP = `Platform Preparation`,
         PLATABRASION = `PlatformAbrasion`, PLATFORMWIDTH = `Platform Width`,
         PLATFORMTHICKNESS = `Platform Thickness`, STAGE = `Flaking Stage`,
         MAXLENGTH = `Maximum Length`, TECHLENGTH = `Technological Length`,
         MAXWIDTH = `Maximum Width`, TECHWIDTH = `Technological Width`,
         MAXTHICKNESS = Thickness, MASS = Mass) |>
  
  select(-c(`...2`,Notes:Photo))

df_Two_flakes <- df_Two |>
  
  add_column(OTHERUNIT = NA, .before = "RAWMATERIAL") |>
  
  mutate(STRAT = ifelse(STRAT == "3a", "3", # combine strat 3a and 3b
                    ifelse(STRAT == "3b", "3", 
                           ifelse(STRAT == "5a", "5", STRAT))),
          STRAT_mod = ifelse(STRAT %in% c("5"),"Terrestrial",
                     ifelse(STRAT %in% c("4a", "4b"), "Mixed", "Coastal"))) |>
  mutate(STRAT = factor(STRAT),
         STRAT_mod = factor(STRAT_mod))




df_Two_flakes <- df_Two_flakes[1:421,] |>
  relocate(CORTEXTYPE, .before = "ARTIFACTCLASS")
  

df_students <- rbind(df_Two_flakes, df_One_flakes)


df <- rbind(df_sum24, df_sum25) |>
  merge(df_students, all = T) |>
  mutate(TECHLENGTH = as.numeric(TECHLENGTH),
         MAXWIDTH = as.numeric(MAXWIDTH),
         MAXTHICKNESS = as.numeric(MAXTHICKNESS)) |>
  filter(STRAT %in% c("1", "2", "3", "4a", "4b", "5")) |>
  
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS == "flake", "Flake",
                         ifelse(ARTIFACTCLASS == "blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Flake/Blade", "Flake",
                         ifelse(ARTIFACTCLASS == "Fragment", "Flake",
                                                     ARTIFACTCLASS)))),
         
         RAWMATERIAL = as.factor(
           ifelse(RAWMATERIAL == "Silcrete flake", "Silcrete",
                              ifelse(RAWMATERIAL == "OTHER", "Other",
                                     RAWMATERIAL))),
         
         CORTEX = ifelse(CORTEX == "10-40%", "11-40%",
                  ifelse(CORTEX == "90-99%", "91-99%",
                  ifelse(CORTEX == "60-90%", "61-90%",
                  ifelse(CORTEX == "40-60%", "41-60%",
                         CORTEX))))) |>
  
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete"),
         CORTEX != "\\",
         MAXWIDTH < 1250)


# take average core flake scar length
df |>
  dplyr::filter(ARTIFACTCLASS=="Core") |>
  group_by(RAWMATERIAL)|>
  dplyr::summarise(a = mean(LENGHTLONGESTFLAKESCAR)) -> df.core_average

# Subset data by flakes and flake variables
df.flakes <- df |>
  filter(ARTIFACTCLASS == "Flake" & COMPLETENESS == "Complete") |>
  select(any_of(names(df_students))) |>
  
  mutate(Utility = MAXWIDTH*MAXLENGTH,
         Reduction = ifelse(
           RAWMATERIAL == "Silcrete", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Silcrete")],
                      ifelse(RAWMATERIAL == "Quartz", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Quartz")],
                       ifelse(RAWMATERIAL == "Quartzite", 
          TECHLENGTH/df.core_average$a[which(df.core_average == "Quartzite")],
                              TECHLENGTH/17.70))))

# Subset data by cores and core variables
df.cores <- df |>
  filter(ARTIFACTCLASS == "Core" & CORECOMPLETENESS == "Complete") |>
  select(1:10,21:28,61:70) |>
  mutate(SA_Ellipse = (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)))

# Subset data by retouch and retouch variables
df.retouch <- df |>
  filter(ARTIFACTCLASS == "RetouchedTool" & RAWMATERIAL != "BWA UPPER 1" &
           COMPLETENESS == "Complete") |>
  select(1:11,21:27,29:60)

# Read tabulated data from previous publications (i.e. Jerardino & Yates)
sbf_df <- read.csv("../data/SBF_ToolType.csv")
sbf_un <- read.csv("../data/SBF_ToolType_unmod.csv")
```

## Raw material distribution

```{r tab.cap="Count and percentage of the three main lithic categories conditioned by raw material: Cores, Flakes, and Retouched tools. Retouched tool categories contains miscelleneous retouched flakes, backed tools, and scrapers."}
#| label: tab-one


# Create summary table

df |>
  mutate(across(where(is.factor), droplevels)) |>
  select(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  mutate(ARTIFACTCLASS = ifelse(ARTIFACTCLASS ==
                                  "RetouchedTool", "Retouched tools", ARTIFACTCLASS),
         RAWMATERIAL = 
           fct_relevel(RAWMATERIAL,
                       "Quartz", "Quartzite", "Silcrete")) |>
  rename(Layer = STRAT,
         `Artifact class` = ARTIFACTCLASS) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  tbl_strata(
    strata = RAWMATERIAL,
    .tbl_fun =
      ~ .x |>
        tbl_summary(by = "Artifact class", missing = "no") |> add_n()
  ) |>
  modify_header(label = "") -> tab1
tab1

#gtsave(tab1, "Table1.png")
```

```{r RMGGplot}
#| message: false
#| warning: false

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Layer",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  guides(fill = "none")+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1)))) -> RM_plot1

df |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  group_by(STRAT_mod, RAWMATERIAL, ARTIFACTCLASS) |>
  summarize(Freq = n()) |>
  mutate(cs = sum(Freq),
         prop = Freq/cs) |>
  ggplot(aes(x = STRAT_mod, y = prop, fill = ARTIFACTCLASS))+
  geom_col()+
  facet_wrap(~RAWMATERIAL)+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Proportion") +
  theme_minimal()+
  theme_classic(base_size = 20)+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1)),
                       angle = 45, hjust = 1)) -> RM_plot2

```

```{r fig-Figure1, fig.cap="Proportion of three main lithic tool types (cores, flakes, and retouched tools) conditioned by raw material type for layers grouped by diet (A) and all layesr (B). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}

png("../results/figures/fig5.png", width = 290, height = 120, units = "mm", res = 300)
ggarrange(
  RM_plot2, RM_plot1,
  align = "h", labels = c("A", "B"),
  common.legend = TRUE
)

dev.off()

```

```{r CortexGGplot}
#| warning: false
#| message: false

# calculate the cortical to noncortical ratio based on percent of cortex and artifact surface area
iter = 100
df_cortex_boot <- tibble(STRAT = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(1234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95, 1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}


# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  
  
  
# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT, y = median, fill = RAWMATERIAL))+
  geom_bar(data = df_emp_cortex, aes(x = STRAT, y = ratio, fill = RAWMATERIAL),
           stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Layer",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",3),
                           rep("dark cyan",2),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot1
  
################## Bootstrap for modified Strats #####################
iter = 100
df_cortex_boot <- tibble(STRAT_mod = character(),
                         ratio = numeric(),
                         RAWMATERIAL = character(),
                         sample = numeric())
set.seed(234567890)
for(i in 1:iter){
df |>
  mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  select(STRAT_mod, RAWMATERIAL, SA, C_SA, NC_SA, cortical) |>
  slice_sample(n = nrow(df), replace = T) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum,
            sample = i) |>
  select(ratio, RAWMATERIAL, sample) -> df_cortex
  
  df_cortex_boot <- rbind(df_cortex, df_cortex_boot)
}

# Compute cortical to noncortical ratio from empirical data
df_emp_cortex <- df |>
    mutate(SA = ifelse(ARTIFACTCLASS == "Core", (4*pi)*
           ((((((MAXLENGTH/2)*(MAXWIDTH/2))^1.6075)+
           (((MAXLENGTH/2)*(MAXTHICKNESS/2))^1.6075)+
           (((MAXWIDTH/2)+(MAXTHICKNESS/2))^1.6075))/3)^(1/1.6075)),
           MAXLENGTH*MAXWIDTH),
         
         cortical = ifelse(CORTEX == "0%", 0,
                    ifelse(CORTEX == "1-10", 0.05,
                    ifelse(CORTEX == "11-40%", 0.25,
                    ifelse(CORTEX == "41-60%", 0.5,
                    ifelse(CORTEX == "61-90%", 0.75, 
                    ifelse(CORTEX == "91-99%", 0.95,1)))))),
         
         C_SA = SA*cortical) |>
  mutate(NC_SA = ifelse(CORTEX == "0%", SA, 0)) |>
  filter(SA < 2000) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(cortical_sum = sum(C_SA),
            noncortical_sum = sum(NC_SA),
            ratio = cortical_sum/noncortical_sum)
  

# Plot cortical to noncortical ratios with error bars from bootstrap data
df_cortex_boot |>
  group_by(RAWMATERIAL, STRAT_mod) |>
  summarise(lower_CI = quantile(ratio, 0.025, na.rm = T),
            upper_CI = quantile(ratio, probs = 0.975, na.rm = T),
            median = quantile(ratio, probs = 0.5, na.rm = T))|>
  ggplot(aes(x = STRAT_mod, y = median, fill = RAWMATERIAL))+
  geom_bar(stat = "identity", position = "dodge")+
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI, colour = "grey"),
                position = "dodge")+
  labs(fill = "",
       x = "Grouped Layers",
       y = "Cortical-to-Noncortical") +
  theme_minimal()+
  guides(colour = "none")+
  scale_fill_viridis_d()+
  theme(axis.text.x = 
          element_text(colour = 
                         c(rep("sky Blue",1),
                           rep("dark cyan",1),
                           rep("green", 1))),
        text = element_text(size= 20)) -> cort_plot2

rm(df_cortex_boot)
```

```{r fig-Figure2, fig.cap="Bar plot that shows the cortical-to-noncortical ratios scaled by artifact's surface area for layers grouped by diet (A) and all layers (B). Low ratio implies greater non-cortical coverage; high ratios imply greater cortical coverage. The error bars reflect a 95% confidence interval derived from bootstrap sampling. Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}

png("../results/figures/fig6.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  cort_plot2, cort_plot1,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r AllMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
fit_df <- df |>
    mutate(log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,0.5), class = "b",
        coef = "STRAT_modMixed:RWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")

  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(1,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")
```

```{r fitAllMass}
fit_mass_all_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325777
)

fit_mass_all_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 2325778
)
```

### Supp 1-2

```{r tab-AllMassGroup}
emmeans_res <- emmeans(fit_mass_all_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)


supp_tab1 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 1. Posterior Estimate of the marginal means for the mass of all lithics conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab1, "../results/tables/Supp1.png")



```

```{r tab-AllMassInd}
emmeans_res <- emmeans(fit_mass_all_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)


supp_tab2 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 2. Posterior Estimate of the marginal means for the mass of all lithics conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab2, "../results/tables/Supp2.png")




# Remove models to expand storage space in R environment
rm(fit_mass_all_grouped)
rm(fit_mass_all_ind)
```

```{r AllMassGGplot}

df |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  mutate(STRAT_mod = as.factor(STRAT_mod),
         RAWMATERIAL = as.factor(RAWMATERIAL)) |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+

  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["QUant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Grouped Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Artifact Mass")+
  labs(fill = "")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank())+
  theme_classic(base_size = 18)+
  guides(color = "none")+
    theme(axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
          text = element_text(size = 20))+
  scale_fill_viridis_d() -> Art_mass_freqPlot2



```

```{r fig-Figure3, fig.cap="Boxplot of log-mass for layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}

png("../results/figures/fig7.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Art_mass_freqPlot1,Art_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreMass}
# design model to look at the relationship between artifact mass and the 50th and 75th percentiles
fit_df <- df |>
    select(MASS, STRAT, RAWMATERIAL, ARTIFACTCLASS, STRAT_mod) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL),
           log_MASS = log(MASS))


# Cretae priors to assign to Bayesian model for two scenarios: grouped and separate layers
# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(3,0.5), class = "Intercept")+
  
  prior(normal(1, 0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(1,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(3,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(2,0.5), class = "Intercept")+
  
  prior(normal(2,1), class = "b", coef = "STRAT2")+
  prior(normal(2,1), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(1,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(1,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(gamma(2, 0.5), class = "shape")
```

```{r CoreMassBayesMods}
fit_mass_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257777
)

fit_mass_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = Gamma(link = "log"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 23257788
)
```

### Supp 3-4

```{r tab-CoreMassGroup}
#| warning: false
#| message: false
#| error: false


emmeans_res <- emmeans(fit_mass_core_grouped, ~ STRAT_mod*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab3 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 3. Posterior Estimate of the marginal means for the mass of core tools conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab3, "../results/tables/Supp3.png")
```

```{r tab-CoreMassInd}
emmeans_res <- emmeans(fit_mass_core_ind, ~ STRAT*RAWMATERIAL)

# Pairwise comparisons with Bayesian credible intervals

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab4 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 4. Posterior Estimate of the marginal means for the mass of core tools conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab4, "../results/tables/Supp4.png")

# Remove models to expand storage space in R environment
rm(fit_mass_core_grouped)
rm(fit_mass_core_ind)
```

```{r CoreMassGGplot}
#| warning: false
#| message: false
df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(log(MASS), probs = 0.75, na.rm = T),
         Median_mid50 = quantile(log(MASS), probs = 0.5, na.rm = T),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)



fit_df |>
  ggplot(aes(x = STRAT_mod, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Grouped Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = log_MASS, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
    geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]], 
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
    theme_minimal()+
  theme(legend.title = element_blank())+
  xlab("Layers")+ylab("log-Core Mass")+
  ylim(-5,5)+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_mass_freqPlot2
```

```{r fig-Figure4, fig.cap="Boxplot of log-mass for only cores in layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}

png("../results/figures/fig8.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_mass_freqPlot1, Core_mass_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

```{r CoreLength}
# Looking only at core Mass
fit_df <- df |>
    select(MASS, STRAT, STRAT_mod, RAWMATERIAL, MAXLENGTH, ARTIFACTCLASS) |>
    filter(ARTIFACTCLASS == "Core") |>
    mutate(RAWMATERIAL = as.factor(RAWMATERIAL))


# Gamma prior for grouped layers and Mass
Gamma_Prior_Mass_Grouped <- prior(normal(log(18),1), class = "Intercept")+
  
  prior(normal(2,0.5), class = "b", coef = "STRAT_modMixed")+
  prior(normal(2,0.5), class = "b", coef = "STRAT_modTerrestrial")+
  
  prior(normal(5,1), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(1,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(2,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALQuartzite")+
  
  prior(normal(3,1), class = "b",
        coef = "STRAT_modMixed:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT_modTerrestrial:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

# Gamma prior for individual layers and Mass
Gamma_Prior_Mass_Ind <- prior(normal(log(18),0.5), class = "Intercept")+
  
  prior(normal(3,0.5), class = "b", coef = "STRAT2")+
  prior(normal(2,0.5), class = "b", coef = "STRAT3")+
  prior(normal(1,1), class = "b", coef = "STRAT4a")+
  prior(normal(1,1), class = "b", coef = "STRAT4b")+
  prior(normal(0.5,1), class = "b", coef = "STRAT5")+
  
  prior(normal(3,0.5), class = "b", coef = "RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b", coef = "RAWMATERIALSilcrete")+
  
  prior(normal(3,0.5), class = "b",
        coef = "STRAT2:RAWMATERIALQuartzite")+
  prior(normal(0,1), class = "b",
        coef = "STRAT2:RAWMATERIALSilcrete")+
  prior(normal(3,0.5), class = "b",
        coef = "STRAT3:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT3:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4a:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4a:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT4b:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT4b:RAWMATERIALSilcrete")+
  prior(normal(3,1), class = "b",
        coef = "STRAT5:RAWMATERIALQuartzite")+
  prior(normal(2,1), class = "b",
        coef = "STRAT5:RAWMATERIALSilcrete")+
  
  prior(exponential(1), class = "sigma")

```

```{r CoreLengthBayesMods}
fit_length_core_grouped <- brm(
  MASS ~ STRAT_mod*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Grouped,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 557777
)

fit_length_core_ind <- brm(
  MASS ~ STRAT*RAWMATERIAL,
  data = fit_df,
  family = lognormal(link = "identity"),
  prior = Gamma_Prior_Mass_Ind,
  cores = getOption("mc.cores", parallel::detectCores()),
  chains = 4,
  iter = 4000,
  seed = 537788
)
```

### Supp 5-6

```{r tab-CoreLengthGroup}
emmeans_res <- emmeans(fit_length_core_grouped, ~ STRAT_mod*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

#plot(emmeans_res)

supp_tab5 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 5. Posterior Estimate of the marginal means for the maximum core length conditioned by individual layer and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab5, "../results/tables/Supp5.png")
```

```{r tab-CoreLengthInd}
emmeans_res <- emmeans(fit_length_core_ind, ~ STRAT*RAWMATERIAL)

pairs1 <- pairs(emmeans_res) |>
  as_tibble() |>
  rename(Contrast = contrast,
         Estimate = estimate,
         `Lower CI` = lower.HPD,
         `Upper CI` = upper.HPD)

color_me <- which(
    (pairs1$`Lower CI` > 0 & pairs1$`Upper CI` > 0) |
    (pairs1$`Lower CI` < 0 & pairs1$`Upper CI` < 0)
  )

#plot(emmeans_res)
supp_tab6 <- pairs1 |>
  
  filter((`Lower CI` < 0 & `Upper CI`) < 0 | 
         (`Lower CI` > 0 & `Upper CI` > 0)) |>
  
  gt() |>
  fmt_number(columns = where(is.numeric), decimals = 2) |>
  tab_caption("Supplemental Table 6. Posterior Estimate of the marginal means for the maximum core length conditioned by grouped layers and raw material.") |>
  tab_header(
    title = "Statistically Significant Posterior Estimates",
    subtitle = "95% Credible Intervals (CI)"
  ) |>
  cols_label(
    Estimate = "Posterior Mean",
    `Lower CI` = "Lower CI",
    `Upper CI` = "Upper CI"
  ) |>
  tab_options(
    table.font.size = px(12),
    data_row.padding = px(3),
    table.border.top.width = px(2),
    table.border.bottom.width = px(2)
  )

gtsave(supp_tab6, "../results/tables/Supp6.png")

# Remove models to expand storage space in R environment
rm(fit_length_core_grouped)
rm(fit_length_core_ind)
```

```{r CoreLengthGGplot}
#| warning: false
#| message: false

df |>
  filter(ARTIFACTCLASS == "Core") |>
  select(MASS, STRAT, RAWMATERIAL, MAXLENGTH, STRAT_mod) |>
  group_by(STRAT_mod) |>
  mutate(Quant_lower75 = quantile(MAXLENGTH, probs = 0.75),
         Median_mid50 = quantile(MAXLENGTH, probs = 0.5),
         dist_to_lower75 = MASS - Quant_lower75,
         dist_to_median = MASS - Median_mid50) -> df_mod

hline_aq <- df_mod |> filter(STRAT_mod == "Coastal") |>
  distinct(Median_mid50, Quant_lower75)
hline_mix <- df_mod |> filter(STRAT_mod == "Mixed") |>
  distinct(Median_mid50, Quant_lower75)
hline_ter <- df_mod |> filter(STRAT_mod == "Terrestrial") |>
  distinct(Median_mid50, Quant_lower75)


fit_df |>
  ggplot(aes(x = STRAT_mod, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT_mod)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.1,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "skyblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan", lty = 2)+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  
  xlab("Grouped Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",1),
                           rep("darkcyan",1),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot1


fit_df |>
  ggplot(aes(x = STRAT, y = MAXLENGTH, fill = RAWMATERIAL, 
                   group = interaction(RAWMATERIAL, STRAT)))+
  geom_boxplot()+
  geom_point(aes(color = "white"),
             position = position_jitterdodge(jitter.width = 0.09,
                                             jitter.height = 0, dodge.width = 0.75),
             alpha = 0.4)+
  
  geom_hline(yintercept = hline_aq[["Median_mid50"]], color = "skyblue")+
  geom_hline(yintercept = hline_mix[["Median_mid50"]], color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Median_mid50"]], color = "lightgreen")+
    
  geom_hline(yintercept = hline_aq[["Quant_lower75"]],
             color = "lightblue", lty = 2)+
  geom_hline(yintercept = hline_mix[["Quant_lower75"]],
             color = "darkcyan")+
  geom_hline(yintercept = hline_ter[["Quant_lower75"]],
             color = "lightgreen", lty = 2)+
  
  xlab("Layers")+ylab("Core Length")+
  theme_minimal()+
  theme(legend.title = element_blank(),
        axis.text.x = 
          element_text(colour = 
                         c(rep("skyblue",3),
                           rep("darkcyan",2),
                           rep("lightgreen", 1))),
        text = element_text(size = 20))+
  guides(color = "none")+
  scale_fill_viridis_d() -> Core_length_freqPlot2
```

```{r fig-Figure5, fig.cap="Boxplot of the maximum core length in layers grouped by diet (A) and for all layers (B). The dashed lines reflect 75th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). The solid lines reflect the 50th percentile mass for layers associated with auqatic diets (blue) and terrestrial diets (green). Blue labeled layers (1, 2, and 3) reflect Coastal-dominated diets, and the green layers (4a and 4b) reflect terrestrial-dominated diets."}

png("../results/figures/fig9.png", width = 290, height = 120,
    units = "mm", res = 300)

ggarrange(
  Core_length_freqPlot1, Core_length_freqPlot2,
  align = "h", labels = c("A", "B"),
  font.label = list(size = 25, face = "bold"),
  common.legend = TRUE
)

dev.off()
```

## Toolkit composition

```{r fig-Figure6, fig.cap="Percent of retouched tools to lithic density at SBF. Higher formal tools and lower lithic density implies higher mobility; lower formal tools and higher lithic density implies lower mobility. These data suggest layers 1, 2, and 3 are asscoaited with increased mobility and layers 4a and 4b are associated with lower mobility."}

png("../results/figures/fig10.png", width = 180, height = 120,
    units = "mm", res = 300)
# Data pulled from Jerardino, 2022
sbf_df |>
  mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
  group_by(Layer) |>
  summarize(Tool_sum = sum(Count)) |>
  mutate(Lithic_Dens = c(602.7, 850.9,
                         ((819+1861)/((819/1863.6)+(1861/1094.7))),
                         2904.3, 1545.6, 2788.5),
         Dep_rate = abs(c(((2.45+2)/2)-((2.6+2.2)/2),
                      ((2.6+2.2)/2)-((3+2.4)/2),
                      ((3+2.4)/2)-((3.5+2.7)/2),
                      ((3.5+2.7)/2)-((5+3)/2),
                      ((5+3)/2)-(4.6),
                      ((9.7+4.6)/2)-(9.7)))) |>
  left_join(
    
    sbf_un |>
      mutate(Layer = ifelse(Layer %in% c("3a", "3b"), "3", Layer)) |>
      group_by(Layer) |>
      summarize(Deb_sum = sum(Count)) 
    
) |>
  mutate(Tool_Perc = (Tool_sum/Deb_sum)*100,
         Lithic_std = Lithic_Dens/Dep_rate) |>
  
  ggplot(aes(x = Lithic_std, y = Tool_Perc, color = Layer, label = Layer))+
  geom_point(size = 3)+
  geom_text(aes(fontface = 2),hjust = 1.5, vjust = 0, size = 5)+
  xlab("Lithic Density/Deposition Rate")+ylab("Formal Tool Percent")+
  theme_minimal()+
  theme(text = element_text(size = 20))+
  guides(color = "none")+
  scale_color_manual(values = c("1" = "skyblue", "2" = "skyblue", "3" = "skyblue",
                                "4a" ="darkcyan", "4b" = "darkcyan",
                                "5" = "lightgreen"))

dev.off()
```

## Flake utility and reduction intensity

```{r flakeUtRed}
#| warning: false
#| message: false

df.flakes |>
  select(STRAT, STRAT_mod, RAWMATERIAL, Utility, Reduction) |>
  group_by(STRAT_mod, RAWMATERIAL) |>
  summarize(Utility_ave = mean(Utility),
            Red_ave= mean(Reduction),
            
            Est_ut = seq(150, 700, 10),
            Est_red = Est_ut^35) |>
  ggplot(aes(x = Red_ave, y = Utility_ave, 
                   color = STRAT_mod, label = STRAT_mod))+
    #geom_point(aes(x = Est_red, y = Est_ut))+
    geom_point(size = 2)+
    facet_wrap(~RAWMATERIAL)+
  
  
    xlab("Reduction Intensity")+ylab("Utility")+
    theme(legend.title = element_blank())+
    guides(color = "none")+
    scale_color_manual(values = c("Coastal" = "skyblue", 
                                  "Mixed" = "darkcyan",
                                "Terrestrial" = "lightgreen")) -> FlakeUtRed1
###########################


```

```{r fig-Figure7, fig.cap="Flake utility to reduction intensity for quartz, quartzite, and silcrete colored by terrestrial (green) and coastal (blue) diets. Our initial hypothesis predicts that as hunter-gatherers focused on coastal resources, we would expect greater flake utility nd reduction intensity.s These pattersn fail to support this hypothesis."}

png("../results/figures/fig11.png", width = 180, height = 120,
    units = "mm", res = 300)

df.flakes |>
  select(STRAT, STRAT_mod, RAWMATERIAL, Utility, Reduction) |>
  group_by(STRAT, RAWMATERIAL) |>
  na.omit()|>
  summarize(Utility_ave = mean(Utility),
            Red_ave = mean(Reduction)) |>
  ggplot(aes(x = Red_ave, y = Utility_ave, 
                   color = STRAT, label = STRAT))+
    geom_point(size = 2)+
    facet_wrap(~RAWMATERIAL)+
    geom_text(aes(fontface = 2),hjust = 1.1, vjust = -0.2)+
  
  
    xlab("Reduction Intensity")+ylab("Flake Utility")+
    theme_light()+
    theme(legend.title = element_blank(), text = element_text(size = 15))+
    guides(color = "none")+
    scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                   "3" = "skyblue",
                                   "4a" = "darkcyan", "4b" = "darkcyan",
                                   "5" = "lightgreen"))

dev.off()
```

## Retouched flake utility to retouch intensity

```{r FlakeRetouch}
df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "MinimallyRetouched") |>
  mutate(Ratio =
           ((EDGETHICKNESS_1+EDGETHICKNESS_2+EDGETHICKNESS_3)/3)/MAXTHICKNESS,
         Region = RETOUCHREGIONNUMBER/8,
         Ratio = rescale(Ratio, to = c(0, 10)),
         Region = rescale(Region, to = c(0, 10))) |>
  select(STRAT, UNIT, RAWMATERIAL, Ratio, Region, MASS, MAXWIDTH, MAXLENGTH,
         MAXTHICKNESS, RETOUCHREGIONLOCATION, LENGTHLONGESTRETOUCH) -> ret_int

```

```{r fig-Figure8, fig.cap="Flake utility to retouch intensity for quartz, quartzite, and silcrete colored by terrestrial (green) and coaastal (blue) diets. Our initial hypothesis predicts that, as hunter-gatherers focused on coastal resources, flake utility should increase and retouch should decrease. Quartzite and silcrete fail to support are hypothesis, and quartz shows an inverse pattern to our expectations."}

png("../results/figures/fig12.png", width = 180, height = 120,
    units = "mm", res = 300)

ret_int |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Quartzite", "Silcrete")) |>
  summarize(Ratio_m = mean(Ratio), Region_m = mean(Region),
            MWidth = mean(MAXWIDTH), MLength = mean(MAXLENGTH)) |>
  ggplot(aes(x = (Ratio_m+Region_m)/2, y = MWidth*MLength, 
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  facet_wrap(~RAWMATERIAL)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Flake Retouch Intensity")+ylab("Flake Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Cores

```{r coreVolumeRemoved}
df.flakes |>
  select(RAWMATERIAL, STRAT, PLATFORMTHICKNESS, MAXTHICKNESS) |>
  group_by(RAWMATERIAL, STRAT) |>
  na.omit() |>
  summarize(m_plat = mean(PLATFORMTHICKNESS),
            m_thick = mean(MAXTHICKNESS)) |>
  arrange(STRAT, RAWMATERIAL) -> flake.vr

flake.vr |>
  left_join(df.cores) |>
  select(m_plat, m_thick,
         STRAT, RAWMATERIAL, MAXLENGTH, MAXWIDTH, MAXTHICKNESS,
         FLAKEGENERATIONSTHICKNESS, FLAKEGENERATIONSLENGTH, FLAKEGENERATIONSWIDTH,
         SA_Ellipse, SCARCOUNT) |>
  na.omit() |>
  group_by(RAWMATERIAL, STRAT) |>
  mutate(V = pi*(4/3)*(MAXLENGTH/2)*(MAXWIDTH/2)*(MAXTHICKNESS/2),
         VR = pi*(4/3)*((MAXLENGTH + (m_plat*FLAKEGENERATIONSLENGTH))/2)*
                       ((MAXWIDTH + (m_plat*FLAKEGENERATIONSWIDTH))/2)*
                       ((MAXTHICKNESS + (m_thick*FLAKEGENERATIONSTHICKNESS))/2),
         volume_removed = (V/VR)*100,
         
         SDI = SCARCOUNT/SA_Ellipse) |>
  select(STRAT, RAWMATERIAL, V, VR, volume_removed, SDI, SA_Ellipse)-> cores.vr
```

```{r fig-Figure9, fig.cap="Core utility to core reduction intensity colored by terrestrial (green) and coaastal (blue) diets. Due to sample size constraints, this figure is based on quartz cores. Our initial hypothesis predicts that as hunter-gatherer exploit coastal resources, core utility and reduction intensity should increase. There is no evidence too support our initial hypothesis."}
# Tells us:
# High reduction intensity and low utility is more mobile
# High reduction and high utility is sedentary but low reduction and high utility is fully sedentary?
# Low reduction intensity and low utility means not focused on flake production?

png("../results/figures/fig13.png", width = 180, height = 120,
    units = "mm", res = 300)

cores.vr |>
  group_by(STRAT, RAWMATERIAL) |>
  summarize(volume_ave = mean(V),
            sdi_ave = mean(SDI),
            volumeRec_mean = mean(volume_removed)) |>
  ggplot(aes(x = volumeRec_mean, y = log(volume_ave),
             color = STRAT, label = STRAT))+
  geom_point(size = 2)+
  geom_text(aes(fontface = 2),hjust = -0.2, vjust = -0.5)+
  facet_grid(~RAWMATERIAL)+
  
  
  xlab("Core Reduction Intensity")+ylab("log-Core Utility")+
  theme_light()+
  theme(legend.title = element_blank(), 
        text = element_text(size = 15))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Scraper utility and retouch intensity

```{r scraperRetouchIntensity}
# Define a database for scraper retouch
df.scrap <- df.retouch |>
  filter(RETOUCHEDPIECETYPOLOGY == "SideScraper" | 
           RETOUCHEDPIECETYPOLOGY == "EndScraper" |
           RETOUCHEDPIECETYPOLOGY == "Side-EndScraper") |>
  select("SCRAPERRETOUCHHEIGHT1", "SCRAPERRETOUCHHEIGHT2", "SCRAPERRETOUCHHEIGHT3",
         "SCRAPERRETOUCHANGLE1", "SCRAPERRETOUCHANGLE2", "SCRAPERRETOUCHANGLE3",
         "SCRAPERDORSALANGLE1", "SCRAPERDORSALANGLE2", "SCRAPERDORSALANGLE3",
         "SCRAPERRETOUCHLENGTH",
         "SCRAPERMAXTHICKNESS",
         "MAXLENGTH", "MAXWIDTH",
         
         "RAWMATERIAL", "STRAT", "MASS") |>
  na.omit() |>
  mutate(RET_INT = round(((SCRAPERRETOUCHHEIGHT1+
                            SCRAPERRETOUCHHEIGHT2+
                            SCRAPERRETOUCHHEIGHT3)/SCRAPERMAXTHICKNESS)*
                           SCRAPERRETOUCHLENGTH,2),
         SA = MAXLENGTH*MAXWIDTH)


# Preprocess data to enter into custom function to calculate scraper reduction
scrap.red <- df.scrap |>
  na.omit() |>
  mutate(D = (SCRAPERRETOUCHHEIGHT1+SCRAPERRETOUCHHEIGHT2+SCRAPERRETOUCHHEIGHT3)/3,
         a = (SCRAPERRETOUCHANGLE1+SCRAPERRETOUCHANGLE2+SCRAPERRETOUCHANGLE3)/3,
         b = (SCRAPERDORSALANGLE1+SCRAPERDORSALANGLE2+SCRAPERDORSALANGLE3)/3) |>
  rename(L = SCRAPERRETOUCHLENGTH)

scrap.red <- scraper_red(scrap.red$L, scrap.red$D, scrap.red$a, scrap.red$b)/1000

scrap.red <- scrap.red |>
  mutate(RETOUCH = as.vector(scrap.red$Reduction),
         STRAT = df.scrap$STRAT,
         UTILITY = df.scrap$MAXWIDTH*df.scrap$MAXLENGTH,
         
         RAWMATERIAL = df.scrap$RAWMATERIAL,
         
         RE_Ut = UTILITY/Reduction,
         
         MASS = df.scrap$MASS)
```

```{r fig-Figure10, fig.cap="Scraper utility to retouch intensity for all scrapers at SBF colored by terrestrial (green) and coastal (blue) diets. Our initial hypothesis predicts that as hunter-gatherers focused on coastal resources, scraper utility increases and retouch intensity decreases. This figure shows the opposite pattern than we would expect."}

png("../results/figures/fig14.png", width = 180, height = 120,
    units = "mm", res = 300)

scrap.red |>
  group_by(STRAT, RAWMATERIAL) |>
  filter(RAWMATERIAL %in% c("Quartz", "Silcrete")) |>
  summarize(Retouch_ave = mean(RETOUCH),
            Utility_ave = mean(UTILITY))|>
  ggplot(aes(x = Retouch_ave, y = Utility_ave, 
             color = STRAT, label = STRAT))+
  geom_point(size = 3)+
  facet_grid(~RAWMATERIAL)+
  geom_text(aes(fontface = 2.5),hjust = -0.2, vjust = -0.5)+
  
  
  xlab("Scraper Retouch Intensity")+ylab("Scraper Utility")+
  theme_light()+
  theme(legend.title = element_blank(),
        text = element_text(size = 17))+
  guides(color = "none")+
  scale_colour_manual(values = c("1" = "skyblue", "2" = "skyblue",
                                 "3" = "skyblue",
                                 "4a" = "darkcyan", "4b" = "darkcyan",
                                 "5" = "lightgreen"))

dev.off()
```

## Adzes

```{r}
df_adze <- df |>
  as_tibble() |>
  filter(RETOUCHEDPIECETYPOLOGY == "Adze") |>
  select(STRAT, RAWMATERIAL, SCARCOUNT,
         MAXLENGTH, MAXWIDTH, MAXTHICKNESS, MASS) |>
  mutate(SA = 2*((MAXLENGTH*MAXWIDTH)+
                   (MAXTHICKNESS*MAXWIDTH)+
                   (MAXTHICKNESS*MAXLENGTH)),
         SDI = SA/SCARCOUNT)

df_adze |>
  ggplot(aes(x = STRAT, y = SDI))+
  geom_boxplot()

df_adze |>
  ggplot(aes(x = STRAT, y = log(MASS)))+
  geom_boxplot()

TukeyHSD(aov(lm(SDI~STRAT, data = df_adze)))
```
